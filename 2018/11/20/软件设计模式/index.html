<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://yoursite.com/warn.html">
<![endif]-->
<meta charset="utf-8">
<!-- 
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
 -->
<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://yoursite.com">
<meta name="author" content="Cooper Yang">
<link rel="stylesheet" href="/css/SimpleStyle.min.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>软件设计模式 - Cooper Yang</title>

<meta name="keywords" content="">

<meta name="description " content="">

</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="说">说</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>Home</span></a>
        <a href="/archives" title="Archives"><i class="fa fa-archives"></i><span>Archives</span></a>
        <a href="/tags" title="Tags"><i class="fa fa-tags"></i><span>Tags</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">说IT</h1>
        <h3 class="cover-siteTitle">用代码摇滚这个世界</h3>
        <p class="cover-siteDesc">一个关注技术与人文的IT博客</p>
        <div class="cover-sns">
            
            <div class="btn btn-github">
                <a href="https://github.com/Foreverb" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>
        
        
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">Input Search key Words Here</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="Input Search key Words Here" />
        <button type="submit" class="search-form-submit" title="Search"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="" target="_blank">
                    <img width="48" src="" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="" target="_blank"></a>
                    <span title="最后编辑于2018-11-20">2018-11-20</span>
                </p>
                <p></p>
            </div>
            <h2 class="post-title">软件设计模式</h2>
            <div class="post-meta">
                本文总共7156个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
<p>为什么要提倡”Design Pattern”呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？OO界有前辈的几个原则：”开－闭”原则(Open Closed Principal)、里氏代换原则、合成复用原则。设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1.什么是设计模式</p>
<p>答：设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
<p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。可以针对某一系列问题提供一个实现的思想，框架，让设计条理清晰。</p>
<p>2.为什么需要设计模式</p>
<p>答：设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。因此，我们需要设计模式来解决复杂问题，使得分析问题更加明了，增强代码的可读性。</p>
<p>如果不使用设计模式对于简单的代码并没有什么影响，当代码长度过长的时候，不使用设计模式会使得代码晦涩难懂，缺乏可读性。运用设计模式让代码分块，更容易管理。</p>
<p>3.设计模式能给我们带来什么</p>
<p>答： 首先能给我们带来解决一类问题的基本思路，让实现起来更加清晰，并且设计完成之后，代码可重用性高。并且由于设计模式要遵循开闭原则，让后期代码维护也更加简单。最后要说的一点是，设计模式让使用者考虑问题养成从整体到局部的实现顺序，使得完成的更加顺利，合理运用类图使得实现简便。</p>
<p>4.设计模式学习面临的困难和解决思路</p>
<p>答： 设计模式初学起来会有些困难，因为模式种类多样，要去分别理解，而且设计模式还要遵循开闭等原则，学习初期可能会有点问题。并且设计模式采用的是自顶向下的设计方法，通过类图来做一个整体的构思，如果设计不好可能会对之后的实现造成困难。要想解决这些问题，首先要有钻研的精神，肯用功，要弄清楚这么多种设计模式的基本思想。并且还要多运用设计模式，运用设计模式要比理解还难，所以多运用，增强对设计模式的理解。</p>
<p>5.如何做到从了解模式到应用模式</p>
<p>答：首先应该正确理解设计模式，模式所关注的不仅是重复的解决方案，更主要的是关注重复出现的应用场景和与场景相关的各种作用力。其次应该针对问题，采取正确的设计模式，实际动手操作。应该做到看到一个问题能分析出需求的紧要程度，要在那个部分着重进行设计。还可以通过阅读成功的设计模式，来深入掌握设计模式的精髓，仔细分析成功的设计模式的设计思想，方便自己在之后中运用。</p>
<h2 id="四个要素"><a href="#四个要素" class="headerlink" title="四个要素"></a>四个要素</h2><p>设计模式使人们可以更加简单方便地复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。</p>
<h3 id="模式名称"><a href="#模式名称" class="headerlink" title="模式名称"></a>模式名称</h3><p>一个助记名，它用一两个词来描述模式的问题、解决方案和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>描述问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg" alt="image"></p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>总体来说设计模式分为三大类：</p>
<p>五种创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>七种结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>十一种行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><ul>
<li>工厂方法模式</li>
</ul>
<p>工厂方法模式的创建是因为简单工厂模式有一个问题，在简单工厂模式中类的创建依赖工厂类，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以就出现了工厂方法模式，只需要创建一个工厂接口和多个工厂实现类，子类可以自己决定实例化哪一个工厂类，client类针对抽象接口进行编程，如果需要增加新的功能，继承工厂接口，直接增加新的工厂类就可以了，创建过程延迟到子类中进行，不需要修改之前的代码，满足了开闭原则，达到灵活地生产多种对象。</p>
<ul>
<li>抽象工厂模式</li>
</ul>
<p>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。区别于工厂方法模式的地方，工厂方法模式是创建一个工厂，可以实现多种对象；而抽象工厂模式是提供一个抽象工厂接口，里面定义多种工厂，每个工厂可以生产多种对象。前者的重点在于”怎么生产”，后者的重点在于”生产哪些”；前者是一个抽象产品类，可以派生出多个具体产品类，后者是多个抽象产品类，每个抽象产品类可以派生出多个具体产品类；前者的每个具体工厂类只能创建一个具体产品类的实例，后者的每个具体工厂类可以创建多个具体产品类的实例。</p>
<ul>
<li>单例模式</li>
</ul>
<p>单例模式能保证一个类仅有一个实例，并提供一个访问它的全局访问点，同时在类内部创造单一对象，通过设置权限，使类外部无法再创造对象。单例对象能保证在一个JVM中，该对象只有一个实例存在，这样做的好处就在于如果某些类创建比较频繁，特别是对于一些大型的对象，这是一笔很大的系统开销。在创建的时候，省去了new操作符，降低了系统内存的使用频率，减轻了系统的压力。同时单例模式保证在一个jvm中仅存在一个实例的好处就在于好比一个军队当中只会存在一个最高级别的军官来指挥整个军队，这样才能保证独立控制整个过程，否则如果出现多个，肯定会杂乱无序。</p>
<ul>
<li>建造者模式</li>
</ul>
<p>建造者模式是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示，就好比是每个饭店或者每家都会做西红柿炒鸡蛋，最后虽然都是西红柿炒鸡蛋的外观，但是由于当中的做饭过程存在差别，所以味道会不同。在程序当中就是将一些不会变的基本组件，通过builder来进行组合，构建复杂对象，实现分离。这样做的好处就在于客户端不必知道产品内部组成的细节；同时具体的建造者类之间是相互独立的，对系统的扩展非常有利，满足开闭原则；由于具体的建造者类是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p>
<ul>
<li>原型模式</li>
</ul>
<p>原型模式是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。其实就是将对象复制了一份并返还给调用者，对象需继承Cloneable并重写clone()方法。原型模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。分为浅复制和深复制，前者是将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的；后者是将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。</p>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><ul>
<li>适配器模式</li>
</ul>
<p>适配器模式是使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，衔接两个不兼容、独立的接口的功能，使得它们能够一起工作，适配器起到中介的作用。</p>
<ul>
<li>装饰模式</li>
</ul>
<p>装饰器模式是动态地给一个对象添加一些额外的职责，给一个对象增加一些新的功能，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。除了动态的增加，也可以动态的撤销，要做到动态的形式，不可以用继承实现，因为继承是静态的。</p>
<ul>
<li>代理模式</li>
</ul>
<p>代理模式是为其他对象提供一种代理以控制对这个对象的访问，也就是创建类的代理类，间接访问被代理类的过程中，对其功能加以控制。它和装饰器模式的区别在于，装饰器模式为了增强功能，而代理模式是为了加以控制。代理模式就是多一个代理类出来，替原对象进行一些操作，例如买火车票不一定在火车站买，也可以去代售点。再比如打官司需要请律师，因为律师在法律方面有专长，可以替我们进行操作。</p>
<ul>
<li>外观模式</li>
</ul>
<p>外观模式是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。在客户端和复杂系统之间再加一层，提供一个容易使用的外观层。外观模式是为了解决类与类之家的依赖关系的，外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，比如搜狐门户网站，就利用了外观模式。</p>
<ul>
<li>桥接模式</li>
</ul>
<p>桥接模式是将抽象部分与实现部分分离，使它们都可以独立的变化。桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化（突然联想到了mvc模式）。将抽象化与实现化解耦，使得二者可以独立变化，就好比现在常说的mvc模式，view和model之间通过control来控制，达到高内聚低耦合来解耦的目的。</p>
<ul>
<li>组合模式</li>
</ul>
<p>组合模式是将对象组合成树形结构以表示”部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。创建了一个包含自己对象组的类，并提供修改对象组的方法。在系统的文件和文件夹的问题上就使用了组合模式，文件下不可以有对象，而文件夹下可以有文件对象或者文件夹对象。</p>
<ul>
<li>享元模式</li>
</ul>
<p>享元模式是运用共享技术有效地支持大量细粒度的对象。享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，重用现有的同类对象，若未找到匹配的对象，则创建新对象，这样可以减少对象的创建，降低系统内存，提高效率。</p>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><ul>
<li>策略模式</li>
</ul>
<p>策略模式是定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换，且算法的变化不会影响到使用算法的客户。。是为了统一接口下的一系列算法类（也就是多种策略），用一个类将其封装起来，使这些策略可动态切换。策略模式属于行为型模式，是为了使这些策略可以相互切换，是为了选择不同的行为。</p>
<ul>
<li>模版方法模式</li>
</ul>
<p>模板方法模式是定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。该模式就是在一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤，将一些固定步骤、固定逻辑的方法封装成模板方法。调用模板方法即可完成那些特定的步骤。</p>
<ul>
<li>观察者模式</li>
</ul>
<p>观察者模式是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。也就是当被观察者状态变化时，通知所有观察者，这种依赖方式具有双向性，在QQ邮箱中的邮件订阅和RSS订阅，当我们浏览一些博客时，经常会看到RSS图标，意思就是，当你订阅了该文章，如果后续有更新，会及时通知你。这种现象即是典型的观察者模式。</p>
<ul>
<li>迭代器模式</li>
</ul>
<p>迭代器模式是提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。在Java当中，将聚合类中遍历各个元素的行为分离出来，封装成迭代器，让迭代器来处理遍历的任务；使简化聚合类，同时又不暴露聚合类的内部，在我们经常使用的JDK中各个类也都是这些基本的东西。</p>
<ul>
<li>责任链模式</li>
</ul>
<p>责任链模式是避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求。在生活中学生进行请假的过程中，会涉及到，学生请假会一级一级往上批，最终处理，具体由谁批准可能不清楚。在程序当中，现在使用的struts拦截器即用到了责任链模式。</p>
<ul>
<li>命令模式</li>
</ul>
<p>命令模式是将一个请求封装成一个对象，从而使发出者可以用不同的请求对客户进行参数化。模式当中存在调用者、接收者、命令三个对象，实现请求和执行分开；调用者选择命令发布，命令指定接收者。举个例子，司令员下令让士兵去干件事情，司令员的作用是发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。司令士兵命令三者相互解耦，任何一方都不用去依赖其他人。其实struts框架也涉及到命令模式的思想。</p>
<ul>
<li>备忘录模式</li>
</ul>
<p>备忘录模式是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。创建一个备忘录类，用来存储原始类的信息；同时创建备忘录仓库类，用来存储备忘录类，主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，也就是做个备份。在系统当中使用的撤销操作，即是使用了备忘录模式，系统可以保存有限次数的文件状态，用户可以进行上几个状态的恢复，也就是用到了备忘录模式。</p>
<ul>
<li>状态模式</li>
</ul>
<p>状态模式是允许对象在内部状态发生改变时改变它的行为。对象具有多种状态，且每种状态具有特定的行为。在网站的积分系统中，用户具有不同的积分，也就对应了不同的状态；还有QQ的用户状态有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态。</p>
<ul>
<li>访问者模式</li>
</ul>
<p>访问者模式主要是将数据结构与数据操作分离。在被访问的类里面加一个对外提供接待访问者的接口，访问者封装了对被访问者结构的一些杂乱操作，解耦结构与算法，同时具有优秀的扩展性。通俗来讲就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。</p>
<ul>
<li>中介者模式</li>
</ul>
<p>中介者模式是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。例如，MVC模式中control就是model和view的中介者。与适配器区别在于，适配器是为了兼容不同的接口，而中介者是为了将显示和操作分离。</p>
<ul>
<li>解释器模式</li>
</ul>
<p>解释器模式是给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子，基本也就用在这个范围内，适用面较窄，例如：正则表达式的解释等。</p>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>1、开闭原则（Open Close Principle）</p>
<p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p>2、里氏代换原则（Liskov Substitution Principle）</p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>3、依赖倒转原则（Dependence Inversion Principle）</p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、接口隔离原则（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p>5、迪米特法则，又称最少知道原则（Demeter Principle）</p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、合成复用原则（Composite Reuse Principle）</p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">Tags：
            
            <a href="/tags/前端/">前端</a>
            
            <a href="/tags/JS/">JS</a>
            
            <a href="/tags/开发/">开发</a>
            
            <a href="/tags/软件/">软件</a>
            
            <a href="/tags/设计模式/">设计模式</a>
            
        </div>
        
    </article>
    
    <p>本文代表个人观点，内容仅供参考。若有不恰当之处，望不吝赐教！</p>
    
    
</div>
<script src="/js/busuanzi.pure.mini.js"></script>

        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about"  title="About">About</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="help" >急救中心</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/app" title="App下载">App下载</a>
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©2017 基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
            ，作者<a href="https://www.tangkunyin.com" target="_blank">唐先森</a>
            ，Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        

    </div>
</footer>
<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '01/20/2018',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>
