<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>redis 在 mac 下的安装与使用</title>
      <link href="/2019/10/14/2019-10-14:redis%20%E5%9C%A8%20mac%20%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/10/14/2019-10-14:redis%20%E5%9C%A8%20mac%20%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>redis 本质上是一个高性能的 Key，Value 数据库；<br>支持存储的类型相对更多；（String、list、set、hash）；</p><blockquote><p>ps : 查询频率高，且查询的是相同的内容，就用 redis 做缓存；</p></blockquote><p>典型的非关系型数据库，不用写sql语句的数据库；(在高并发的时候对关系型数据库起到一个很好的补充作用)</p><h2 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h2><p>redis 的默认端口是 6379</p><h2 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h2><p><a href="https://redis.io/download" target="_blank" rel="noopener">官网下载</a>  下载 stable 版本，稳定版本。</p><ul><li>解压：tar zxvf redis-4.0.9.tar.gz</li><li>移动到： mv redis-4.0.9 /usr/local/</li><li>切换到：cd /usr/local/redis-4.0.9/</li><li>编译测试 sudo make test</li><li>编译安装 sudo make install</li></ul><h2 id="redis-的启动与停止"><a href="#redis-的启动与停止" class="headerlink" title="redis 的启动与停止"></a>redis 的启动与停止</h2><p>redis-server 和 redis-cli 位于 redis-4.0.9/src 目录下</p><ul><li>启动方式一：直接启动 Redis： redis-server ，成功后会看到下图：</li></ul><p><a href="https://img-blog.csdn.net/20180419163909844?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmFzb25fTV9Ibw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener">查看效果</a></p><ul><li><p>启动方式二：启动 Redis 并加载配置文件： redis-server /etc/redis.conf</p></li><li><p>打开redis客户端 redis-cli；如果有密码，可使用 auth yourpassword 做简单的密码登录</p></li><li><p>关闭方式一：在客户端执行 SHUTDOWN 可关闭 redis 服务</p></li><li><p>如果关闭不了就加一个参数，执行 SHUTDOWN NOSAVE 可关闭 redis 服务</p></li><li><p>关闭方式二：如果用了zsh，可以执行kill redis并按tab，结束 redis 进程，也可在活动监视器里结束掉进程。</p></li></ul><h2 id="redis-配置"><a href="#redis-配置" class="headerlink" title="redis 配置"></a>redis 配置</h2><p>这里只配置了后台启动和增加一个连接密码，需要的话可以看一下配置文档，每一个配置都有详细说明：</p><ul><li>拷贝 redis-4.0.9/redis.conf 到 /etc 目录</li><li>修改 redis.conf 配置文件<ul><li>requirepass yourpassword 添加密码，在第500行；</li><li>daemonize yes，设置后台启动，在第136行；</li></ul></li></ul><h2 id="客户端常用命令："><a href="#客户端常用命令：" class="headerlink" title="客户端常用命令："></a>客户端常用命令：</h2><p>命令 ———— ————————用途</p><p>set key value ————————-设置 key的值</p><p>get key ————————-获取 key 的值</p><p>exists key ————————-查看此 key 是否存在</p><p>keys * ————————-查看所有的 key</p><p>flushall ————————-消除所有的 key</p><p><a href="https://img-blog.csdn.net/20180419164115487?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmFzb25fTV9Ibw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener">查看效果</a></p><h2 id="安装时报错解决"><a href="#安装时报错解决" class="headerlink" title="安装时报错解决"></a>安装时报错解决</h2><p>进行了多次安装和卸载，重复安装没有卸载干净会报下面的错</p><p>==[exception]: Executing test client: couldn’t execute “src/redis-benchmark”:<br>make[1]: <strong><em> [test] Error 1 make: </em></strong> [test] Error 2==</p><p>解决这个错误，执行下面的语句即可</p><ul><li>make distclean</li><li>make</li><li>make test</li></ul><p>– end –</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> mac </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vuex</title>
      <link href="/2019/04/26/vuex/"/>
      <url>/2019/04/26/vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h2 id="状态自管理应用包含以下几个部分："><a href="#状态自管理应用包含以下几个部分：" class="headerlink" title="状态自管理应用包含以下几个部分："></a>状态自管理应用包含以下几个部分：</h2><ul><li>state，驱动应用的数据源；</li><li>view，以声明方式将 state 映射到视图；</li><li>actions，响应在 view 上的用户输入导致的状态变化。</li></ul><p><img src="https://vuex.vuejs.org/vuex.png" alt="image"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h5 id="每一个-Vuex-应用的核心就是-store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态-state-。Vuex-和单纯的全局对象有以下两点不同："><a href="#每一个-Vuex-应用的核心就是-store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态-state-。Vuex-和单纯的全局对象有以下两点不同：" class="headerlink" title="每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同："></a>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同：</h5><ul><li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li><li><p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p></li></ul><h2 id="最简单的-Store"><a href="#最简单的-Store" class="headerlink" title="最简单的 Store"></a>最简单的 Store</h2><p>安装 Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;)</span><br><span class="line"></span><br><span class="line">console.log(store.state.count) // -&gt; 1</span><br></pre></td></tr></table></figure><h4 id="再次强调，我们通过提交-mutation-的方式，而非直接改变-store-state-count"><a href="#再次强调，我们通过提交-mutation-的方式，而非直接改变-store-state-count" class="headerlink" title="再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count"></a>再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count</h4><p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h3><p>Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">      &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。</p><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 在单独构建的版本中辅助函数为 Vuex.mapState</span><br><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    // 箭头函数可使代码更简练</span><br><span class="line">    count: state =&gt; state.count,</span><br><span class="line"></span><br><span class="line">    // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count`</span><br><span class="line">    countAlias: &apos;count&apos;,</span><br><span class="line"></span><br><span class="line">    // 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      return state.count + this.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &apos;count&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p>mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; /* ... */ &#125;,</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 接受 state 作为其第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h3><p>Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;]</span><br></pre></td></tr></table></figure><p>Getter 也可以接受其他 getter 作为第二个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // ...</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodosCount // -&gt; 1</span><br></pre></td></tr></table></figure><p>我们可以很容易地在任何组件中使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    return this.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h3><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  // ...</span><br><span class="line">  getTodoById: (state) =&gt; (id) =&gt; &#123;</span><br><span class="line">    return state.todos.find(todo =&gt; todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br></pre></td></tr></table></figure><h5 id="注意，getter-在通过方法访问时，每次都会去进行调用，而不会缓存结果。"><a href="#注意，getter-在通过方法访问时，每次都会去进行调用，而不会缓存结果。" class="headerlink" title="注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。"></a>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</h5><h3 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h3><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将 getter 混入 computed 对象中</span><br><span class="line">    ...mapGetters([</span><br><span class="line">      &apos;doneTodosCount&apos;,</span><br><span class="line">      &apos;anotherGetter&apos;,</span><br><span class="line">      // ...</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span><br><span class="line">  doneCount: &apos;doneTodosCount&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</p><p>这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 变更状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>提交 mutation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p>你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;, 10)</span><br></pre></td></tr></table></figure><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h3><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: &apos;increment&apos;,</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h3><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p><ol><li><p>最好提前在你的 store 中初始化好所有所需属性。</p></li><li><p>当需要在对象上添加新属性时，你应该</p></li></ol><ul><li><p>使用 Vue.set(obj, ‘newProp’, 123), 或者</p></li><li><p>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, newProp: 123 &#125;</span><br></pre></td></tr></table></figure><h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// mutation-types.js</span><br><span class="line">export const SOME_MUTATION = &apos;SOME_MUTATION&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import &#123; SOME_MUTATION &#125; from &apos;./mutation-types&apos;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      // mutate state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h3><p>一条重要的原则就是要记住 mutation 必须是同步函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation (state) &#123;</span><br><span class="line">    api.callAsyncMethod(() =&gt; &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h3 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h3><p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapMutations` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p>让我们来注册一个简单的 action：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(&apos;increment&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p><h3 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h3><p>Action 通过 store.dispatch 方法触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&apos;increment&apos;)</span><br></pre></td></tr></table></figure><p>mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit(&apos;increment&apos;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actions 支持同样的载荷方式和对象方式进行分发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 以载荷形式分发</span><br><span class="line">store.dispatch(&apos;incrementAsync&apos;, &#123;</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 以对象形式分发</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: &apos;incrementAsync&apos;,</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    // 把当前购物车的物品备份起来</span><br><span class="line">    const savedCartItems = [...state.cart.added]</span><br><span class="line">    // 发出结账请求，然后乐观地清空购物车</span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    // 购物 API 接受一个成功回调和一个失败回调</span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      // 成功操作</span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      // 失败操作</span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p><h3 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h3><p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line"></span><br><span class="line">      // `mapActions` 也支持载荷：</span><br><span class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)`</span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h3><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><p>首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        commit(&apos;someMutation&apos;)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  // ...</span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    return dispatch(&apos;actionA&apos;).then(() =&gt; &#123;</span><br><span class="line">      commit(&apos;someOtherMutation&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果我们利用 <a href="https://tc39.github.io/ecmascript-asyncawait" target="_blank" rel="noopener">async / await</a>，我们可以如下组合 action：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  async actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(&apos;gotData&apos;, await getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    await dispatch(&apos;actionA&apos;) // 等待 actionA 完成</span><br><span class="line">    commit(&apos;gotOtherData&apos;, await getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p><ol><li><p>应用层级的状态应该集中到单个 store 对象中。</p></li><li><p>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。</p></li><li><p>异步逻辑都应该封装到 action 里面。</p></li></ol><p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p><p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       # 购物车模块</span><br><span class="line">        └── products.js   # 产品模块</span><br></pre></td></tr></table></figure><p> <a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">Module</a></p><p><a href="https://vuex.vuejs.org/zh/guide/plugins.html" target="_blank" rel="noopener">插件</a></p><p><a href="https://vuex.vuejs.org/zh/guide/strict.html" target="_blank" rel="noopener">严格模式</a></p><p><a href="https://vuex.vuejs.org/zh/guide/forms.html" target="_blank" rel="noopener">表单处理</a></p><p><a href="https://vuex.vuejs.org/zh/guide/testing.html" target="_blank" rel="noopener">测试</a></p><p><a href="https://vuex.vuejs.org/zh/guide/hot-reload.html" target="_blank" rel="noopener">热重载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客 </tag>
            
            <tag> vue </tag>
            
            <tag> 框架 </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基本vue-router配置</title>
      <link href="/2019/04/20/%E5%9F%BA%E6%9C%ACvue-router%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/20/%E5%9F%BA%E6%9C%ACvue-router%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们</p><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Hello App!&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;!-- 使用 router-link 组件来导航. --&gt;</span><br><span class="line">    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span><br><span class="line">    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;!-- 路由出口 --&gt;</span><br><span class="line">  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">// 1. 定义 (路由) 组件。</span><br><span class="line">// 可以从其他文件 import 进来</span><br><span class="line">const Foo = &#123; template: &apos;&lt;div&gt;foo&lt;/div&gt;&apos; &#125;</span><br><span class="line">const Bar = &#123; template: &apos;&lt;div&gt;bar&lt;/div&gt;&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 2. 定义路由</span><br><span class="line">// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是</span><br><span class="line">// 通过 Vue.extend() 创建的组件构造器，</span><br><span class="line">// 或者，只是一个组件配置对象。</span><br><span class="line">// 我们晚点再讨论嵌套路由。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123; path: &apos;/foo&apos;, component: Foo &#125;,</span><br><span class="line">  &#123; path: &apos;/bar&apos;, component: Bar &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 3. 创建 router 实例，然后传 `routes` 配置</span><br><span class="line">// 你还可以传别的配置参数, 不过先这么简单着吧。</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes // (缩写) 相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 4. 创建和挂载根实例。</span><br><span class="line">// 记得要通过 router 配置参数注入路由，</span><br><span class="line">// 从而让整个应用都有路由功能</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br><span class="line"></span><br><span class="line">// 现在，应用已经启动了！</span><br></pre></td></tr></table></figure><p>通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Home.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    username () &#123;</span><br><span class="line">      // 我们很快就会看到 `params` 是什么</span><br><span class="line">      return this.$route.params.username</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    goBack () &#123;</span><br><span class="line">      window.history.length &gt; 1</span><br><span class="line">        ? this.$router.go(-1)</span><br><span class="line">        : this.$router.push(&apos;/&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客 </tag>
            
            <tag> vue </tag>
            
            <tag> 框架，vue-router </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue项目主文件</title>
      <link href="/2019/04/10/vue%E9%A1%B9%E7%9B%AE%E4%B8%BB%E6%96%87%E4%BB%B6/"/>
      <url>/2019/04/10/vue%E9%A1%B9%E7%9B%AE%E4%B8%BB%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="vue项目中app-vue-、main-js和-index-html的关联"><a href="#vue项目中app-vue-、main-js和-index-html的关联" class="headerlink" title="vue项目中app.vue 、main.js和 index.html的关联"></a>vue项目中app.vue 、main.js和 index.html的关联</h1><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>index.html是我们的根文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;my-project&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>main.js是我们的入口文件，主要作用是初始化vue实例并使用需要的插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App&apos;</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h2><p>App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Hello from &apos;./components/Hello&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客 </tag>
            
            <tag> vue </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bootStrap用法</title>
      <link href="/2019/03/16/bootStrap/"/>
      <url>/2019/03/16/bootStrap/</url>
      
        <content type="html"><![CDATA[<h2 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h2><ul><li>引入内置css</li></ul><link rel="stylesheet" herf="bootstrap.css"><ul><li><p>引入jq</p><script src="jquery-1.11.1.js"></script></li><li><p>引入内置js</p><script src="bootstrap.js"></script></li></ul><hr><h2 id="bootstrap栅格系统"><a href="#bootstrap栅格系统" class="headerlink" title="bootstrap栅格系统"></a>bootstrap栅格系统</h2><h3 id="容器（className）"><a href="#容器（className）" class="headerlink" title="容器（className）"></a>容器（className）</h3><pre><code>-- container-fluid    》流体-- container    》固定    》1170    》750    》auto</code></pre><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code>- 分12列（className）    》row    》col    col-lg-3    col-md-3    col-sm-3    cll-sx-3- 阈值    》 1200 &gt;=    》 992 &gt;=    》 768 &gt;=    》 768 &lt;=</code></pre><ul><li>列偏移</li></ul><pre><code>col-[ lg|md|sm|sx ]-offest-【1-12】</code></pre><ul><li>列排序</li></ul><pre><code>col-[ lg|md|sm|sx ]-[ push | pull ]-[ 1-12 ]push 往后排pull 往前排</code></pre><h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li>针对不同设备展示或隐藏页面内容</li></ul><h4 id="可见类"><a href="#可见类" class="headerlink" title="可见类"></a>可见类</h4><ul><li>visibile-<em>-</em></li></ul><p>可选项</p><blockquote><p>lg md sm sx</p></blockquote><blockquote><p>block inline inline-block</p></blockquote><h4 id="不可见类"><a href="#不可见类" class="headerlink" title="不可见类"></a>不可见类</h4><ul><li>hidden-*</li></ul><blockquote><p>lg md sm sx</p></blockquote><p>打印类</p><ul><li>visible-prient-*  hidden-prient</li></ul><h3 id="Glyphicons字体图标"><a href="#Glyphicons字体图标" class="headerlink" title="Glyphicons字体图标"></a>Glyphicons字体图标</h3><ul><li>好处<ul><li>减少请求</li><li>容易控制</li><li>例子：淘宝</li></ul></li><li>用法</li></ul><p>添加class：“glyphucons glyphicons-图标名”</p><pre><code>- font-face- 字体路径</code></pre><ul><li>自制图标</li></ul><p>百度搜索：“把图标转化成web字体”</p><h3 id="预定义样式风格"><a href="#预定义样式风格" class="headerlink" title="预定义样式风格"></a>预定义样式风格</h3><ul><li>primary（首选项）</li><li>success（成功）</li><li>info（一般信息）</li><li>warning（警告）</li><li>danger（危险）</li></ul><p>button样式风格</p><blockquote><p>class=”btn btn-[primary|success|info|warning|danger]”</p></blockquote><p>字体样式风格</p><blockquote><p>class=”text-[primary|success|info|warning|danger]”</p></blockquote><p>背景样式风格</p><blockquote><p>class=”bg-[primary|success|info|warning|danger]”</p></blockquote><p>警告框样式风格</p><blockquote><p>class=”alert alert-[primary|success|info|warning|danger]”</p></blockquote><p>面板样式风格</p><blockquote><p>class=”panel panel-[primary|success|info|warning|danger]”</p></blockquote><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><ul><li>基类<ul><li>btn</li></ul></li><li>样式<ul><li>btn-default（默认）</li><li>btn-link（链接）</li></ul></li><li>大小<ul><li>btn-*【lg|sm|sx】</li></ul></li><li>状态<ul><li>active</li><li>disabled</li></ul></li><li>种类<ul><li>a、input、button</li></ul></li><li>块级<ul><li>btn-block</li></ul></li><li>按钮组<ul><li>btn-group</li><li>btn-group-justified</li><li>btn-group-vertical</li></ul></li><li>箭头<ul><li>caret   向下</li><li>dropup  向上</li></ul></li></ul><h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><ul><li>属性<ul><li>data-*</li><li>aria-*</li><li>role</li></ul></li><li>open</li><li>drop-down-menu-right</li><li>dropdown-header</li><li>divider   分割线</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">下拉</span><br><span class="line"></span><br><span class="line">class=&quot;data-toggle&quot;</span><br><span class="line">data-toggle=&quot;dropdown&quot;</span><br><span class="line"></span><br><span class="line">加给点击的目标元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">判断移动端还是pc端</span><br><span class="line"></span><br><span class="line">pc</span><br><span class="line"></span><br><span class="line">window.navigator.userAgent.toLowerCase().indexOf(&apos;mobile&apos;) == -1</span><br><span class="line"></span><br><span class="line">mobile</span><br><span class="line"></span><br><span class="line">window.navigator.userAgent.toLowerCase().indexOf(&apos;mobile&apos;) != -1</span><br></pre></td></tr></table></figure><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><ul><li>头部<ul><li>nav</li><li>nav-tabs</li><li>nav-justified</li><li>nav-tabs-justified</li><li>nav-pills</li><li>nav-stacked</li></ul></li><li>内容<ul><li>tab-content</li><li>tab-pane</li><li>data-toggle=’tab’</li><li>herf对应id</li><li>淡入淡出  fade</li></ul></li></ul><h3 id="导航条"><a href="#导航条" class="headerlink" title="导航条"></a>导航条</h3><p>除第二个，其他全是加给容器（nav）</p><ul><li>navbar navbar-default     默认</li><li>nav navbar-nav    菜单    （子集）</li><li>navbar-inverse</li><li>navbar-static-top</li><li>navbar-fixed-top</li><li>navbar-fixed-bottom</li></ul><hr><ul><li>navbar-header</li><li>mavbar-brand          logo</li><li>navbar-left           左浮动  菜单（子集）</li><li>navbar-right          右浮动  菜单（子集）</li><li>navbar-btn</li><li>navbar-link</li><li>navbar-text</li><li>navbar-form</li></ul><hr><ul><li>响应式导航条<ul><li>navbar-toggle</li><li>collapse navbar-collapse      添加到隐藏对象上</li></ul></li><li>滚动监听<ul><li>data-spy = “scroll”           </li><li>data-target = { id }          隐藏对象的id</li><li>data-offest = “距离”</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工具 </tag>
            
            <tag> bootStrap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack用法</title>
      <link href="/2019/03/13/webpack/"/>
      <url>/2019/03/13/webpack/</url>
      
        <content type="html"><![CDATA[<p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 主入口</span><br><span class="line">  entry: &apos;./src/app.js&apos;,</span><br><span class="line">  // 输出</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname,&apos;dist&apos;),</span><br><span class="line">    filename: &apos;main.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 插件</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      template: &apos;src/index.html&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  //loader</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;babel-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              presets: [&apos;react&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      //识别css文件</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line">      //识别图片</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|gif)$/,</span><br><span class="line">        use: [&apos;file-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line">      //识别字体</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(ttf|eot|woff|woff2|svg)$/,</span><br><span class="line">        use: [&apos;file-loader&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">  //服务配置</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    port: 9090</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html-webpack-plugin</span><br></pre></td></tr></table></figure><h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p>loader 就是webpack用来预处理模块的，在一个模块被引入之前，会预先使用loader处理模块的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">react       例: npm i -S react</span><br><span class="line"></span><br><span class="line">react-dom</span><br><span class="line"></span><br><span class="line">label-loader    例：npm i -D babel-loader</span><br><span class="line"></span><br><span class="line">label-core</span><br><span class="line"></span><br><span class="line">label-preset-react</span><br></pre></td></tr></table></figure><h3 id="引入css"><a href="#引入css" class="headerlink" title="引入css"></a>引入css</h3><p>处理css文件中出现的url，会自动帮你引入里面要引入的模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style-loader</span><br><span class="line"></span><br><span class="line">css-loader</span><br></pre></td></tr></table></figure><h3 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h3><p>1、把你的资源移动到输出目录</p><p>2、返回最终引入资源的url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file-loader</span><br></pre></td></tr></table></figure><p>默认将图片以base64编码，当图片过大时不建议使用</p><p>可以设置limit属性，在可控范围进行编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url-loader</span><br></pre></td></tr></table></figure><h1 id="devserver"><a href="#devserver" class="headerlink" title="devserver"></a>devserver</h1><p>服务配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    port: 9090</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="引入字体"><a href="#引入字体" class="headerlink" title="引入字体"></a>引入字体</h1><h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br><span class="line"></span><br><span class="line">简写：npm i -D babel-cli</span><br></pre></td></tr></table></figure><h2 id="babel插件与babel预设"><a href="#babel插件与babel预设" class="headerlink" title="babel插件与babel预设"></a>babel插件与babel预设</h2><p>预设：preset<br>插件：plugin</p><p>因为用babel编译js文件的时候，对于es6中的语法，不同的语法需要不同的插件去编译，所以衍生出了babel预设</p><p>babel预设就是将所有需要用到的插件打包在一个文件中，我们只需要通过命令下载，然后在自己创建的 ==.babelrc== 文件中使用即可</p><p>下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D babel-cli babel-preset-es2015</span><br></pre></td></tr></table></figure></p><p>使用（文件 .babelrc）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;preset&quot;: [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工具 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序start</title>
      <link href="/2019/03/11/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8/"/>
      <url>/2019/03/11/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="App"><a href="#App" class="headerlink" title="App"></a>App</h2><p>小程序运行期间，之后运行一次</p><p>程序销毁（过了一段时间没有运行，或手动删除了小程序，再次添加运行）之后，再次启动就好执行</p><p>onLaunch</p><p>每次在后台切换过来，就会执行</p><p>onShow</p><p>每次在切换到后台，就会执行</p><p>onHide</p><h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><p>页面加载的时候执行，只会执行一次</p><p>onLoad</p><p>页面第一次完成之后，只会执行一次</p><p>onReady</p><p>页面显示就会执行</p><p>onShow</p><p>页面隐藏就会执行</p><p>onHide</p><p>页面卸载的时候执行，只会执行一次</p><p>onUnload</p><p>结论：</p><p>1、tab之间的切换，不会让页面重新加载，也就不会卸载只会隐藏</p><p>2、在进行NavigatorTo，跳转到的那个目标页面会被加载（load），跳转之前的页面会被隐藏</p><p>3、回退（NavigatorBack），目标页面会show（不是加载），回退之前的页面会被卸载（unload）</p><h1 id="条件渲染和block"><a href="#条件渲染和block" class="headerlink" title="条件渲染和block"></a>条件渲染和block</h1><ul><li>wx:for</li><li>wx:if</li><li>wx:elif</li><li>wx:else</li><li>wx:key</li></ul><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><template name=""></template><p>要想复用上面的模板，只需要在引用处的template标签中加”is”属性，值为被引用的模板“name”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;block&gt;&lt;/block&gt;</span><br><span class="line"></span><br><span class="line">&lt;import/&gt;</span><br><span class="line"></span><br><span class="line">&lt;include/&gt;</span><br><span class="line"></span><br><span class="line">&lt;veiw&gt;&lt;/veiw&gt;</span><br><span class="line"></span><br><span class="line">&lt;text&gt;&lt;/text&gt;</span><br></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>绑定事件</p><ul><li>bind:eventName=”eventFunction”</li><li>catch:eventName=”eventFunction”</li></ul><p>catch绑定事件，可以阻止事件冒泡</p><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>单位 ：rpx</p><p>屏幕最大宽度是750rpx</p><p>font-size: 20pt</p><h2 id="支持的选择器"><a href="#支持的选择器" class="headerlink" title="支持的选择器"></a>支持的选择器</h2><p>.class</p><p>#id</p><p>element</p><p>element,element</p><p>:after</p><p>:before</p><h1 id="辅助渲染（wxs）"><a href="#辅助渲染（wxs）" class="headerlink" title="辅助渲染（wxs）"></a>辅助渲染（wxs）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs name=&quot;&quot;&gt;</span><br><span class="line">    定义函数</span><br><span class="line"></span><br><span class="line">    modul.export = &quot;functionName&quot;</span><br><span class="line">&lt;wxs&gt;</span><br></pre></td></tr></table></figure><h1 id="更新页面"><a href="#更新页面" class="headerlink" title="更新页面"></a>更新页面</h1><p>setData（{}）</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>展现形式</p><p>例：<input>,<button></button>,<view></view></p><p>类似于标签</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>navigator</p><p>属性</p><p>url     属性值：src</p><p>open-type</p><pre><code>属性值navigate        跳转到  === wx.navigateTo(OBJECT)redirect        重定向  === wx.redirectTo(OBJECT)switchTab       跳到某个Tab === wx.switchTab(OBJECT)navigateBack    回退    === wx.navigateBack(OBJECT)reLaunch        重加载 === wx.reLaunch(OBJECT)</code></pre><h1 id="授权与用户信息授权"><a href="#授权与用户信息授权" class="headerlink" title="授权与用户信息授权"></a>授权与用户信息授权</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  open-type=&quot;getUserInfo&quot;</span><br><span class="line">  bind:getuserinfo=&quot;onGetUserInfo&quot;</span><br><span class="line">&gt;获取用户信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button bind:tap=&quot;onTry&quot;&gt;</span><br><span class="line">  获取用户信息试试</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button</span><br><span class="line">  bind:tap=&quot;onAuthLocation&quot;</span><br><span class="line">&gt;授权位置&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button</span><br><span class="line">  bind:tap=&quot;onGetLocation&quot;</span><br><span class="line">&gt;获取位置</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button</span><br><span class="line">  bind:tap=&quot;onGetSetting&quot;</span><br><span class="line">&gt;获取授权信息</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button</span><br><span class="line">  bind:tap=&quot;onGoToSetting&quot;</span><br><span class="line">&gt;打开授权信息相关面板</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">onGetUserInfo(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;,</span><br><span class="line">  onTry(e)&#123;</span><br><span class="line">    wx.getUserInfo(&#123;</span><br><span class="line">      success: <span class="function"><span class="params">msg</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg,<span class="string">"success"</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e,<span class="string">"fail"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onAuthLocation()&#123;</span><br><span class="line">    wx.authorize(&#123;</span><br><span class="line">      scope: <span class="string">"scope.userLocation"</span>,</span><br><span class="line">      success: <span class="function"><span class="params">msg</span>=&gt;</span><span class="built_in">console</span>.log(msg,<span class="string">'success'</span>),</span><br><span class="line">      fail: <span class="function"><span class="params">e</span>=&gt;</span><span class="built_in">console</span>.log(e,<span class="string">'fail'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onGetLocation()&#123;</span><br><span class="line">    wx.getLocation(&#123;</span><br><span class="line">      success:<span class="function"><span class="params">msg</span>=&gt;</span><span class="built_in">console</span>.log(msg,<span class="string">'get success'</span>),</span><br><span class="line">      fail:<span class="function"><span class="params">e</span>=&gt;</span><span class="built_in">console</span>.log(e,<span class="string">'get fail'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onGetSetting()&#123;</span><br><span class="line">    wx.getSetting(&#123;</span><br><span class="line">      success:<span class="function"><span class="params">msg</span>=&gt;</span><span class="built_in">console</span>.log(msg),</span><br><span class="line">      fail:<span class="function"><span class="params">e</span>=&gt;</span><span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onGoToSetting()&#123;</span><br><span class="line">    wx.openSetting(&#123;</span><br><span class="line">      success:<span class="function">(<span class="params">msg</span>)=&gt;</span><span class="built_in">console</span>.log(msg,<span class="string">"open success"</span>),</span><br><span class="line">      fail:<span class="function">(<span class="params">e</span>)=&gt;</span><span class="built_in">console</span>.log(e,<span class="string">"open fail"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//设置数据</span><br><span class="line">setStorage()&#123;</span><br><span class="line">    //异步设置/获取数据</span><br><span class="line">    // wx.setStorage(&#123;</span><br><span class="line">    //     key:&quot;name&quot;,</span><br><span class="line">    //     data:&#123;one:&apos;ygb&apos;&#125;,</span><br><span class="line">    //     success:()=&gt;&#123;</span><br><span class="line">    //         wx.getStorage(&#123;</span><br><span class="line">    //             key:&apos;name&apos;,</span><br><span class="line">    //             success:msg=&gt;&#123;</span><br><span class="line">    //                 console.log(msg)</span><br><span class="line">    //             &#125;</span><br><span class="line">    //         &#125;)</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    //同步设置/获取数据</span><br><span class="line">    wx.setStorageSync(&quot;names&quot;,&quot;ygb2&quot;);</span><br><span class="line"></span><br><span class="line">    let nm = wx.getStorageSync(&apos;names&apos;);</span><br><span class="line"></span><br><span class="line">    console.log(nm);</span><br><span class="line">&#125;,</span><br><span class="line">//删除数据</span><br><span class="line">removeStorage()&#123;</span><br><span class="line">    wx.removeStorageSync(&apos;names&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flex布局</title>
      <link href="/2019/03/01/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2019/03/01/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="http-flexboxfroggy-com"><a href="#http-flexboxfroggy-com" class="headerlink" title="http://flexboxfroggy.com/"></a><a href="http://flexboxfroggy.com/" target="_blank" rel="noopener">http://flexboxfroggy.com/</a></h1><h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">flex-direction</span><br><span class="line"></span><br><span class="line">flex设置主轴方向</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">row     横向（由左向右）</span><br><span class="line"></span><br><span class="line">row-reverse   横向（由右向左）  </span><br><span class="line"></span><br><span class="line">column  纵向（由上至下）</span><br><span class="line"></span><br><span class="line">column-reverse  纵向（由下至上）</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">flex-wrap</span><br><span class="line"></span><br><span class="line">属性用于指定弹性盒子的子元素换行方式。</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nowrap 是flex-wrap的 默认值，弹性容器为单行。该情况下弹性子项可能会溢出容器    </span><br><span class="line"></span><br><span class="line">wrap 就是当子元素宽度总和超过了父级，那么子级就会换行</span><br><span class="line"></span><br><span class="line">wrap-reverse  就是当子元素宽度总和超过了父级，那么该换行的子级就会与不该换行的子级交换位置</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">flex-flow</span><br><span class="line"></span><br><span class="line">是flex-direction和flex-wrap复合属性</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">justify-content</span><br><span class="line"></span><br><span class="line">富裕空间分布（横向）</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">space-between   富裕空间 平均分配在 每两个元素之间</span><br><span class="line"></span><br><span class="line">space-around    富裕空间 每个元素两侧</span><br><span class="line"></span><br><span class="line">center      元素从主轴中间 位置显示,富裕空间在主轴两侧</span><br><span class="line"></span><br><span class="line">flex-start  元素从主轴开始位置显示,富裕空间在主轴结束位置</span><br><span class="line"></span><br><span class="line">flex-end    元素从主轴结束位置显示,富裕空间在主轴开始位置</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">align-items</span><br><span class="line"></span><br><span class="line">富裕空间分布（纵向）</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">center      元素在侧轴中间显示,富裕空间在侧轴两侧</span><br><span class="line"></span><br><span class="line">flex-start   元素在侧轴开始位置显示,富裕空间在侧轴结束位置</span><br><span class="line"></span><br><span class="line">flex-end     元素在侧轴结束位置显示,富裕空间在侧轴开始位置</span><br><span class="line"></span><br><span class="line">baseline    元素在侧轴 根据基线对齐</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">align-content</span><br><span class="line"></span><br><span class="line">属性在弹性容器内的各项没有占用交叉轴上所有可用的空间时对齐容器内的各项（垂直）。</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：容器内必须有多行的项目，该属性才能渲染出效果。</span><br><span class="line">···</span><br></pre></td></tr></table></figure><hr><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">order</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.item &#123;</span><br><span class="line">  order: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">flex-grow</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class="line"></span><br><span class="line">如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">flex-shrink</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line"></span><br><span class="line">如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</span><br><span class="line"></span><br><span class="line">负值对该属性无效。</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">flex-basis</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line"></span><br><span class="line">它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">flex</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</span><br><span class="line"></span><br><span class="line">建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">align-self</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><pre><code>$.ajax({    //jquery的ajax格式    type: &quot;POST&quot;,    url: &quot;ajax.php&quot;,    dataType: &quot;json&quot;,    data:{&quot;val1&quot;:&quot;abc&quot;,&quot;val2&quot;:123,&quot;val3&quot;:&quot;456&quot;,},    beforeSend: function () {        //some js code    },    success: function () {        console.log(msg);    },    error: function () {        console.log(&quot;error&quot;);    }})</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客 </tag>
            
            <tag> flex </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器同源策略及Cookie的作用域</title>
      <link href="/2018/12/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8ACookie%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2018/12/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8ACookie%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="浏览器同源策略及Cookie的作用域"><a href="#浏览器同源策略及Cookie的作用域" class="headerlink" title="浏览器同源策略及Cookie的作用域"></a><a href="https://www.cnblogs.com/liaojie970/p/7606168.html" target="_blank" rel="noopener">浏览器同源策略及Cookie的作用域</a></h4><p>所谓”同源”指的是”三个相同”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.协议相同</span><br><span class="line"></span><br><span class="line">2.域名相同</span><br><span class="line"></span><br><span class="line">3.端口相同</span><br></pre></td></tr></table></figure><p>当着三个地方相同才算同源</p><p>例如：<a href="http://www.example.com:8888/dir/page.html" target="_blank" rel="noopener">http://www.example.com:8888/dir/page.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">协议是http://</span><br><span class="line"></span><br><span class="line">域名是www.example.com</span><br><span class="line"></span><br><span class="line">端口是8888</span><br></pre></td></tr></table></figure><p>采用同源策略的目的：是为了保证用户信息的安全，防止恶意的网站窃取数据。设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。</p><p>如果其他网站可以读取A网站的 Cookie，会发生什么？如果 Cookie包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用</p><p>户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。由此可见，”同源政策”是必需的，否则Cookie 可以共享，互联网就毫无安全可言了</p><p>缺点：如果不是同源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)Cookie、LocalStorage和IndexDB 无法读取</span><br><span class="line"></span><br><span class="line">(2)DOM无法获得</span><br><span class="line"></span><br><span class="line">(3)AJAX请求不能发送</span><br></pre></td></tr></table></figure><h4 id="Cookie的作用域："><a href="#Cookie的作用域：" class="headerlink" title="Cookie的作用域："></a>Cookie的作用域：</h4><p>Cookie有两个很重要的属性:Domain和Path，用来指示此Cookie的作用域：</p><p>　　Domain告诉浏览器当前要添加的Cookie的域名归属，如果没有明确指明则默认为当前域名，比如通过访问<a href="http://www.vinceruan.info添加的Cookie的域名默认就是www.vinceruan.info,通过访问blog.vinceruan.info所生成的Cookie的域名就是blog.vinceruan.info" target="_blank" rel="noopener">www.vinceruan.info添加的Cookie的域名默认就是www.vinceruan.info,通过访问blog.vinceruan.info所生成的Cookie的域名就是blog.vinceruan.info</a></p><p>　　Path告诉浏览器当前要添加的Cookie的路径归属，如果没有明确指明则默认为当前路径，比如通过访问<a href="http://www.vinceruan.info/java/hotspot.html添加的Cookie的默认路径就是/java/,通过blog.vinceruan.info/java/hotspot.html生成的Cookie的路径也是/java/" target="_blank" rel="noopener">www.vinceruan.info/java/hotspot.html添加的Cookie的默认路径就是/java/,通过blog.vinceruan.info/java/hotspot.html生成的Cookie的路径也是/java/</a></p><p>浏览器提交的Cookie需要满足以下两点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当前域名或者父域名下的Cookie；</span><br><span class="line">2.当前路径或父路径下的Cookie</span><br></pre></td></tr></table></figure><p>要满足以上两个条件的Cookie才会被提交,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cookie1 : [name=value,domain=.vinceruan.info path=/]</span><br><span class="line"></span><br><span class="line">cookie2 : [name=value,domain=blog.vinceruan.info path=/java/]</span><br><span class="line"></span><br><span class="line">cookie3 : [name=value,domain=WWW.vinceruan.info path=/]</span><br><span class="line"></span><br><span class="line">cookie4 : [name=value,domain=blog.vinceruan.info path=/]</span><br></pre></td></tr></table></figure><p>当访问blog.vinceruan.info时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cookie1可以被提交，因为.vinceruan.info是blog.vinceruan.info的父域名，path路径也一致</span><br><span class="line"></span><br><span class="line">cookie2不能被提交，因为虽然domain是保持一致的，但是path不一致，当前访问的是/，但是cookie2的path是/java/</span><br><span class="line"></span><br><span class="line">cookie3不能被提交，因为虽然path是一致的，但是WWW.vinceruan.info不是blog.vinceruan.info的父域名</span><br><span class="line"></span><br><span class="line">cookie4可以被提交，因为domain和cookie都严格保持一致</span><br></pre></td></tr></table></figure><p>这里需要注意的是:在浏览器看来.</p><p><a href="http://www.vinceruan.info不是blog.vinceruan.info的父域名，而vinceruan.info才是blog.vinceruan.info的父域名，" target="_blank" rel="noopener">www.vinceruan.info不是blog.vinceruan.info的父域名，而vinceruan.info才是blog.vinceruan.info的父域名，</a></p><p><a href="http://www.vinceruan.info也算是一个二级域名" target="_blank" rel="noopener">www.vinceruan.info也算是一个二级域名</a></p><p>这点如果你提交过域名到DNS服务器商的应该会知道，一般我们需要显式提交<a href="http://www.vinceruan.info和vinceruan.info" target="_blank" rel="noopener">www.vinceruan.info和vinceruan.info</a>, 否则<a href="http://www.vinceruan.info==vinceruan.info是不成立的" target="_blank" rel="noopener">www.vinceruan.info==vinceruan.info是不成立的</a></p><p>所以如果我们需要在所有二级域名下共享islogin=1的Cookie，用java代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie c = new Cookie(&quot;isLogin&quot;,&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">c.setDomain(&quot;.vinceruan.info&quot;);//注意是以号开头</span><br><span class="line"></span><br><span class="line">c.setPath(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure><p>如果要在所有的二级域名下的/java/路径下共享silogin=1的Cookie,用java代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie c = new Cookie(&quot;isLogin&quot;,&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">c.setDomain(&quot;.vinceruan.info&quot;);//注意是以号开头</span><br><span class="line"></span><br><span class="line">c.setPath(&quot;/java/&quot;);</span><br><span class="line"></span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> web </tag>
            
            <tag> 技巧 </tag>
            
            <tag> Cookie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react之Refs的使用</title>
      <link href="/2018/12/16/react%E4%B9%8BRefs%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/16/react%E4%B9%8BRefs%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Refs-的使用"><a href="#Refs-的使用" class="headerlink" title="Refs 的使用"></a>Refs 的使用</h1><p>本文摘自React官方文档</p><p><a href="https://react.css88.com/docs/refs-and-the-dom.html" target="_blank" rel="noopener">https://react.css88.com/docs/refs-and-the-dom.html</a></p><h2 id="Refs-和-DOM"><a href="#Refs-和-DOM" class="headerlink" title="Refs 和 DOM"></a>Refs 和 DOM</h2><blockquote><p>Refs 提供了一种访问在 render 方法中创建的 DOM 节点或 React 元素的方式。</p></blockquote><p>在常规的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改子元素，你需要用新的 props 去重新渲染子元素。然而，在少数情况下，你需要在常规数据流外强制修改子元素。被修改的子元素可以是 React 组件实例，或者是一个 DOM 元素。在这种情况下，React 提供了解决办法。</p><h3 id="何时使用-Refs"><a href="#何时使用-Refs" class="headerlink" title="何时使用 Refs"></a>何时使用 Refs</h3><p>下面有一些正好使用 refs 的场景:</p><ul><li>处理focus、文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方DOM库</li></ul><p>如果可以通过声明式实现，就尽量避免使用 refs 。</p><p>例如，相比于在 Dialog 组件中暴露 open() 和 close() 方法，最好传递 isOpen 属性。</p><h3 id="不要过度使用-Refs"><a href="#不要过度使用-Refs" class="headerlink" title="不要过度使用 Refs"></a>不要过度使用 Refs</h3><p>你可能首先会想到在你的应用程序中使用 refs 来更新组件。如果是这种情况，请花一点时间，更多的关注在组件层中使用 state。在组件层中，通常较高级别的 state 更为清晰。有关示例，请参考<a href="https://react.css88.com/docs/lifting-state-up.html" target="_blank" rel="noopener">状态提升</a>。</p><h3 id="创建-Refs"><a href="#创建-Refs" class="headerlink" title="创建 Refs"></a>创建 Refs</h3><p>使用 React.createRef() 创建 refs，通过 ref 属性来获得 React 元素。当构造组件时，refs 通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h3><p>当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const node = this.myRef.current;</span><br></pre></td></tr></table></figure><p>ref的值取决于节点的类型:</p><ul><li>当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref 。</li><li>当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。</li><li>你不能在函数式组件上使用 ref 属性，因为它们没有实例。</li></ul><p>下面的例子说明了这些差异。</p><h3 id="在-DOM-元素上添加-Ref"><a href="#在-DOM-元素上添加-Ref" class="headerlink" title="在 DOM 元素上添加 Ref"></a>在 DOM 元素上添加 Ref</h3><p>以下代码使用 ref 存储对 DOM 节点的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    // create a ref to store the textInput DOM element</span><br><span class="line">    this.textInput = React.createRef();</span><br><span class="line">    this.focusTextInput = this.focusTextInput.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    // Explicitly focus the text input using the raw DOM API</span><br><span class="line">    // Note: we&apos;re accessing &quot;current&quot; to get the DOM node</span><br><span class="line">    this.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // tell React that we want to associate the &lt;input&gt; ref</span><br><span class="line">    // with the `textInput` that we created in the constructor</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.textInput&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 组件在加载时将 DOM 元素传入 ref 的回调函数，在卸载时则会传入 null。在 componentDidMount 或 componentDidUpdate 这些生命周期回调之前执行 ref 回调。</p><h3 id="为-类-Class-组件添加-Ref"><a href="#为-类-Class-组件添加-Ref" class="headerlink" title="为 类(Class) 组件添加 Ref"></a>为 类(Class) 组件添加 Ref</h3><p>如果我们想要包装上面的 CustomTextInput ，来模拟挂载之后立即被点击的话，我们可以使用 ref 来访问自定义输入，并手动调用它的 focusTexInput 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class AutoFocusTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.textInput.current.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这种方法仅对以类(class)声明的 CustomTextInput 有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Refs-与-函数式组件"><a href="#Refs-与-函数式组件" class="headerlink" title="Refs 与 函数式组件"></a>Refs 与 函数式组件</h2><p>你不能在函数式组件上使用 ref 属性，因为它们没有实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function MyFunctionalComponent() &#123;</span><br><span class="line">  return &lt;input /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // This will *not* work!</span><br><span class="line">    return (</span><br><span class="line">      &lt;MyFunctionalComponent ref=&#123;this.textInput&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要使用 ref ，你需要将组件转化成 类(class)组件，就像需要 生命周期方法 或者 state 一样。</p><p>然而你可以 在函数式组件内部使用 ref 来引用一个 DOM 元素或者 类(class)组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  // textInput必须在这里声明，所以 ref 回调可以引用它</span><br><span class="line">  let textInput = null;</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&quot;text&quot;</span><br><span class="line">        ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input</span><br><span class="line">        type=&quot;button&quot;</span><br><span class="line">        value=&quot;Focus the text input&quot;</span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对父组件暴露-DOM-节点"><a href="#对父组件暴露-DOM-节点" class="headerlink" title="对父组件暴露 DOM 节点"></a>对父组件暴露 DOM 节点</h3><p>在极少数情况下，你可能希望从父组件访问子节点的 DOM 节点。通常不建议这样做，因为它会破坏组件的封装，但偶尔也可用于触发焦点或测量子 DOM 节点的大小或位置。</p><p>虽然你可以向子组件添加 ref，但这不是一个理想的解决方案，因为你只能获取组件实例而不是 DOM 节点。并且，它还在函数式组件上无效。</p><p>如果你使用 React 16.3 或更高, 这种情况下我们推荐使用 ref 转发。 ==Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref==。关于怎样对父组件暴露子组件的 DOM 节点，在 ref 转发文档 中有一个详细的例子。</p><p>如果你使用 React 16.2 或更低，或者你需要比 ref 转发更高的灵活性，你可以使用 这个替代方案 将 ref 作为特殊名字的 prop 直接传递。</p><p>可能的话，我们不建议暴露 DOM 节点，但有时候它会成为救命稻草。注意这些方案需要你在子组件中增加一些代码。如果你对子组件的实现没有控制权的话，你剩下的选择是使用 findDOMNode()，但是不推荐并且在 StrictMode 中已经被弃用。</p><h3 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h3><p>React 也支持另一种设置 ref 的方式，称为“回调 ref”，更加细致地控制何时 ref 被设置和解除。</p><p>不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数接受 React 组件的实例或 HTML DOM 元素作为参数，以存储它们并使它们能被其他地方访问。</p><p>下面的例子描述了一种通用的范例：使用 ref 回调函数，在实例的属性中存储对 DOM 节点的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.textInput = null;</span><br><span class="line"></span><br><span class="line">    this.setTextInputRef = element =&gt; &#123;</span><br><span class="line">      this.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.focusTextInput = () =&gt; &#123;</span><br><span class="line">      // 直接使用原生 API 使 text 输入框获得焦点</span><br><span class="line">      if (this.textInput) this.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 渲染后文本框自动获得焦点</span><br><span class="line">    this.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React</span><br><span class="line">    // 实例上（比如 this.textInput）</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.setTextInputRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 将在组件挂载时将 DOM 元素传入ref 回调函数并调用，当卸载时传入 null 并调用它。在componentDidMout 和 componentDidUpdate 触发之前，Refs 保证是最新的。</p><p>你可以在组件间传递回调形式的 refs，就像你可以传递通过 React.createRef() 创建的对象 refs 一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Parent 传递给它的 ref 回调函数作为 inputRef 传递给 CustomTextInput，然后 CustomTextInput 通过 ref属性将其传递给 <input>。最终，Parent 中的 this.inputElement 将被设置为与 CustomTextIput 中的 <input> 元素相对应的 DOM 节点</p><h3 id="旧版API-String-类型的-Refs"><a href="#旧版API-String-类型的-Refs" class="headerlink" title="旧版API: String 类型的 Refs"></a>旧版API: String 类型的 Refs</h3><p>如果你之前使用过 React ，你可能了解过之前的API中的 string 类型的 ref 属性。类似于 “textInput” ，可以通过 this.refs.textInput 访问DOM节点。我们不建议使用，因为string类型的 refs 存在问题。已经过时了，可能会在未来的版本是移除。如果你目前还在使用 this.refs.textInput 这种方式访问 refs ，我们建议用回调函数的方式代替。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果 ref 回调以内联函数的方式定义，在更新期间会被调用两次，第一次参数是 null ，之后参数是 DOM 元素。这是因为在每次渲染中都会创建一个新的函数实例。因此，React 需要清理旧的 ref 并且设置新的。通过将 ref 的回调函数定义成类的绑定函数的方式可以避免上述问题，但是在大多数例子中这都不是很重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> refs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React的设计模式和最佳实践解读(一)</title>
      <link href="/2018/12/15/React%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/"/>
      <url>/2018/12/15/React%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章-React-基础"><a href="#第-1-章-React-基础" class="headerlink" title="第 1 章 React 基础"></a>第 1 章 React 基础</h1><h2 id="1-1-声明式编程"><a href="#1-1-声明式编程" class="headerlink" title="1.1 声明式编程"></a>1.1 声明式编程</h2><p>命令式编程描述代码如何工作，而声明式编程则表明想要实现什 么目的。</p><p>例 ···</p><p>与命令式世界极其相似的一个真实示例就是去酒吧喝啤酒并对服务员做出以下指示:</p><ul><li>从架子上拿一个玻璃杯;</li><li>将杯子放到酒桶前;</li><li>按下酒桶开关，将杯子倒满;</li><li>把杯子递给我。</li></ul><p>但在声明式世界中，你只需要说:“请给我一杯啤酒。”</p><p>···</p><p>命令式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">toLowerCase([&apos;FOO&apos;, &apos;BAR&apos;]) // [&apos;foo&apos;, &apos;bar&apos;]</span><br><span class="line">const toLowerCase = input =&gt; &#123;</span><br><span class="line">      const output = []</span><br><span class="line">      for (let i = 0; i &lt; input.length; i++) &#123;</span><br><span class="line">        output.push(input[i].toLowerCase())</span><br><span class="line">      &#125;</span><br><span class="line">      return output</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>声明式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toLowerCase([&apos;FOO&apos;, &apos;BAR&apos;]) // [&apos;foo&apos;, &apos;bar&apos;]</span><br><span class="line">const toLowerCase = input =&gt; input.map(</span><br><span class="line">      value =&gt; value.toLowerCase()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>声明式优点</p><ol><li>简洁、易读，这对注重可维护性的大型代码库来说非常重要。</li><li>声明式编程中无须使用变量，也不用在执行过程中持续更新变量的值。事实上，声明式编程往往避免了创建和修改状态。</li><li>开发人员只需要描述他们想要实现什么目的，无须列出实现效果的 所有步骤。</li><li>声明式编程方式使得 React很容易使用，因此最终的代码也很简单，这样产生的 bug 也更少， 可维护性也更强。</li></ol><h2 id="1-2-React元素"><a href="#1-2-React元素" class="headerlink" title="1.2 React元素"></a>1.2 React元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      type: Title,</span><br><span class="line">      props: &#123;</span><br><span class="line">        color: &apos;red&apos;,</span><br><span class="line">        children: &apos;Hello, Title!&apos;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素最重要的属性是 type，另一个比较特殊的属性是 children，它是可选的，用于表示<br>元素的直接后代。当然，元素还具有其他一些属性。</p><p>type 属性很重要，因为它告诉 React 如何处理元素本身。实际上，如果 type 属性是字符串，<br>那么元素就表示 DOM 节点;如果 type 属性是函数，那么元素就是组件。</p><p>DOM 元素和组件可以互相嵌套，以表示整个渲染树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">      type: Title,</span><br><span class="line">      props: &#123;</span><br><span class="line">        color: &apos;red&apos;,</span><br><span class="line">        children: &#123;</span><br><span class="line">          type: &apos;h1&apos;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            children: &apos;Hello, H1!&apos;</span><br><span class="line">          &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当元素的 type 属性是函数时，React 会调用它，传入 props 来取回底层元素。React 会一直 对返回结果递归地执行相同的操作，直到取回完整的 DOM 节点树，然后就可以将它渲染到屏幕。 这个过程称作一致性比较，React DOM 和 React Native 都利用它在各自的平台上创建 UI。</p><h2 id="1-3-忘掉所学的一切"><a href="#1-3-忘掉所学的一切" class="headerlink" title="1.3 忘掉所学的一切"></a>1.3 忘掉所学的一切</h2><h4 id="耦合的定义"><a href="#耦合的定义" class="headerlink" title="耦合的定义"></a>耦合的定义</h4><p>它们(css)定义在不同的文件中，但模板引用了样式文件，而且 CSS 选 择器也遵循了文档标记结构，因此，几乎不可能在不影响其他文件的前提下修改某个文件。</p><h5 id="React-的最终目标是将创建组件所用到的每项技术都封装起来，并根据它们的领域和功能进-行关注点分离"><a href="#React-的最终目标是将创建组件所用到的每项技术都封装起来，并根据它们的领域和功能进-行关注点分离" class="headerlink" title="React 的最终目标是将创建组件所用到的每项技术都封装起来，并根据它们的领域和功能进 行关注点分离"></a>React 的最终目标是将创建组件所用到的每项技术都封装起来，并根据它们的领域和功能进 行关注点分离</h5><p>以下示例展示了 React 文档中的一个样式对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var divStyle = &#123;</span><br><span class="line">  color: &apos;white&apos;,</span><br><span class="line">  backgroundImage: &apos;url(&apos; + imgUrl + &apos;)&apos;, WebkitTransition: &apos;all&apos;, // 注意此处大写的&apos;W&apos; msTransition: &apos;all&apos; // &apos;ms&apos;是唯一小写的厂商前缀</span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render()&#123;</span><br><span class="line">    &lt;div style=&#123;divStyle&#125;&gt; hello word ! &lt;/div&gt;</span><br><span class="line">    mountNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-常见误解"><a href="#1-4-常见误解" class="headerlink" title="1.4 常见误解"></a>1.4 常见误解</h2><h4 id="安装react-cli"><a href="#安装react-cli" class="headerlink" title="安装react-cli"></a>安装react-cli</h4><p>CLI 工具只需要 Node.js/npm 环境，然后就可以全局安装:</p><p>npm install -g create-react-app</p><p>安装好这个可执行程序后，就可以向它传递文件夹名称来创建应用了。</p><p>create-react-app hello-world</p><p>最后，执行 cd hello-world</p><p>命令进入应用的文件夹，接着运行以下命令: npm start</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul><li>声明式编程：只关注目的是什么</li><li>命令式编程：需要描述代码如何工作的</li><li>耦合的定义：模块与模块之间互不影响</li><li>安装react脚手架</li></ul><h1 id="第-2-章-整理代码"><a href="#第-2-章-整理代码" class="headerlink" title="第 2 章 - 整理代码"></a>第 2 章 - 整理代码</h1><ul><li>JSX 是什么，为什么要使用 JSX。</li><li>Babel 是什么，怎样利用它来编写现代 JavaScript 代码。</li><li>JSX 的主要特性以及其与 HTML 之间的区别。</li><li>编写优雅且可维护的 JSX 代码的最佳实践。</li><li>代码检查(尤其是 ESLint)怎样使得多个应用或团队的 JavaScript 代码风格保持一致。</li><li>函数式编程的基础，以及为何遵循函数范式可以使得我们写出更好的 React 组件。</li></ul><h2 id="2-1-JSX"><a href="#2-1-JSX" class="headerlink" title="2.1 - JSX"></a>2.1 - JSX</h2><p>React 提供了两种定义元素的方式。一种是使用 JavaScript 函数，另一种是使用类似 XML 的 JSX 语法。</p><p>虽然JSX看起来像HTML，但它实际上只是一种更灵敏的方式React.createElement()来编写声明</p><p>因为JSX是JavaScript，我们不能使用JavaScript保留字。这包括class和像for。</p><h2 id="2-1-1-Babel"><a href="#2-1-1-Babel" class="headerlink" title="2.1.1 - Babel"></a>2.1.1 - Babel</h2><h3 id="Babel是什么"><a href="#Babel是什么" class="headerlink" title="Babel是什么"></a>Babel是什么</h3><p>它只是一个将源文件转译成输出文件的工具，配置后才能使用一些转换规则。</p><p>为了在代码中使用 JSX(及 ES2015 的特性)，我们需要安装 Babel。</p><p>abel 可以将 ES2015 的 JavaScript 代码编译成 ES5 的，也可以将 JSX 编译成 JavaScript 函数。<br>这个过程称为转译，因为它将源代码编译成另一份新源代码，而不是可执行文件。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>npm install –global babel-cli</p><p>安装完成后，可以运行以下命令来编译任何 JavaScript 文件。</p><p>babel source.js -o output.js</p><p>Babel 如此强大的原因之一在于可以灵活配置。</p><h3 id="预设配置"><a href="#预设配置" class="headerlink" title="预设配置"></a>预设配置</h3><p>npm install –global babel-preset-es2015</p><p>babel-preset-react</p><p>安装完成后，在根文件夹下创建名为.babelrc 的配置文件，并写入以下代码来告诉 Babel 使 用这些预设配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">   &quot;es2015&quot;,</span><br><span class="line">   &quot;react&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-1-2-Hello，World"><a href="#2-1-2-Hello，World" class="headerlink" title="2.1.2 - Hello，World!"></a>2.1.2 - Hello，World!</h2><p>创建 div 元素:</p><p>React.createElement(‘div’)</p><p>以下是 JSX 写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div /&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-1-3-DOM-元素与-React-组件"><a href="#2-1-3-DOM-元素与-React-组件" class="headerlink" title="2.1.3 - DOM 元素与 React 组件"></a>2.1.3 - DOM 元素与 React 组件</h2><p>有了 JSX 后，我们既可以创建 HTML 元素，也可以创建 React 元素;唯一的区别在于它们是否以大写字母开头。</p><p>例如，渲染 HTML 按钮元素时使用<button>，而渲染 Button 组件时使用</button><button>。</button></p><p>前一个按钮会转译为以下代码:</p><p>React.createELement(‘button’)</p><p>后一个按钮会转译为以下代码:</p><p>React.createElement(Button)</p><p>以上区别在于，前一个调用传入了字符串形式的 DOM元素类型，而后者传入了组件本身，这也意味着该组件要存在于当前作用域。</p><h2 id="2-1-4-属性"><a href="#2-1-4-属性" class="headerlink" title="2.1.4 - 属性"></a>2.1.4 - 属性</h2><p>JSX 可以非常方便地书写包含属性的 DOM 元素或 React 组件。实际上，用 XML 设置元素属性就很简单。</p><pre><code>&lt;img src=&quot;https://facebook.github.io/react/img/logo.svg&quot; alt=&quot;React.js&quot; /&gt;JavaScript 的等效写法如下所示:React.createElement(&quot;img&quot;, {  src: &quot;https://facebook.github.io/react/img/logo.svg&quot;,  alt: &quot;React.js&quot;});</code></pre><h2 id="2-1-5-子元素"><a href="#2-1-5-子元素" class="headerlink" title="2.1.5 子元素"></a>2.1.5 子元素</h2><p>JSX 允许定义子元素来描述元素树，并构建复杂的 UI。</p><p>类似 XML 的 JSX 代码拥有更好的可读性和可维护性</p><p>JSX 的妙处在于没有限制只能将元素嵌套为其他元素的子元素，还可以使用函数或变量这样 的 JavaScript 表达式。</p><p>要想这样做，只需要用双花括号括起表达式即可:</p><div><br>  Hello, {variable}.<br>  I’m a {function()}.<br></div><p>同理，这也适用于非字符串属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&#123;this.makeHref()&#125;&gt;Click me!&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="2-1-6-JSX-与-HTML-的区别"><a href="#2-1-6-JSX-与-HTML-的区别" class="headerlink" title="2.1.6 JSX 与 HTML 的区别"></a>2.1.6 JSX 与 HTML 的区别</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>我们要始终牢记，JSX 不是一门标准语言，需要转译成 JavaScript。由于这一点，有些属性无法使用。</p><p>比如，我们需要用 className 取代 class，用 htmlFor 取代for:</p><label classname="awesome-label" htmlfor="name"><p>这是因为 class 和 for 都是 JavaScript 的保留字。</p><h3 id="2-样式"><a href="#2-样式" class="headerlink" title="2. 样式"></a>2. 样式</h3><p>非常明显的区别之一就是样式属性的工作原理。我们将在第 7 章中介绍更多细节，目前只需 要了解其工作原理即可。</p><p>与 HTML 不同，样式属性期望传入 JavaScript 对象，而不是 CSS 字符串，而且样式名的写法 为驼峰式命名法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123; backgroundColor: &apos;red&apos; &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-根元素"><a href="#3-根元素" class="headerlink" title="3. 根元素"></a>3. 根元素</h3><p>JSX 和 HTML 之间还有一个很重要的区别值得一提，因为 JSX 元素会转换为 JavaScript 函数， 但 JavaScript 不允许返回两个函数，因此如果有多个同级元素，需要强制将它们封装在一个父元 素中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line">&lt;div /&gt;</span><br></pre></td></tr></table></figure></p><p>上述代码会导致以下错误:</p><p>Adjacent JSX elements must be wrapped in an enclosing tag</p><p>而以下写法就是有效的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div /&gt;</span><br><span class="line">    &lt;div /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="4-空格"><a href="#4-空格" class="headerlink" title="4. 空格"></a>4. 空格</h3><p>JSX 不是 HTML 这个是事实，尽管它的语 法很像 XML。</p><p>JSX 处理文本和元素间的空格的方式与 HTML 不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;span&gt;foo&lt;/span&gt;</span><br><span class="line">      bar</span><br><span class="line">      &lt;span&gt;baz&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>浏览器解析 HTML 时，以上代码会显示 foo bar baz</p><p>而 JSX 会将同一份代码渲染为 foobarbaz，这是因为嵌套的三行代码转译成了 div 元素的 独立子元素，没有将空格计算在内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div&gt;</span><br><span class="line">      &lt;span&gt;foo&lt;/span&gt;</span><br><span class="line">      &#123;&apos; &apos;&#125;</span><br><span class="line">      bar</span><br><span class="line">      &#123;&apos; &apos;&#125;</span><br><span class="line">      &lt;span&gt;baz&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>JavaScript 表达式封装了空字符串来强制编译器在元素间插入空格</p><h2 id="5-布尔值属性"><a href="#5-布尔值属性" class="headerlink" title="5. 布尔值属性"></a>5. 布尔值属性</h2><p>在 JSX 中定义布尔值属性前，如果设置某个属性却 没有赋值，那么 JSX 会默认其值是 true，这种行为类似 HTML 的 disabled 属性。</p><p>这意味着如果要将属性值设置为 false，则需要显式地声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button disabled /&gt;</span><br><span class="line"></span><br><span class="line">React.createElement(&quot;button&quot;, &#123; disabled: true &#125;);</span><br><span class="line">---</span><br><span class="line">&lt;button disabled=&#123;false&#125; /&gt;</span><br><span class="line"></span><br><span class="line">React.createElement(&quot;button&quot;, &#123; disabled: false &#125;);</span><br></pre></td></tr></table></figure><h2 id="2-1-9-常见模式"><a href="#2-1-9-常见模式" class="headerlink" title="2.1.9 常见模式"></a>2.1.9 常见模式</h2><ol><li>多行书写</li></ol><p>应该倾向于使用 JSX 而不是 createElement 方法， 主要原因之一便是 JSX 的语法很像 XML，而且对称的开闭标签可以完美地表示节点树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Header /&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Main content=&#123;...&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果出现子节点不是元素，而是文本或变量这样的例外情况，那么应该和父节点的标签写在 同一行，并避免产生混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div&gt;</span><br><span class="line">      &lt;Alert&gt;&#123;message&#125;&lt;/Alert&gt;</span><br><span class="line">      &lt;Button&gt;Close&lt;/Button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>多行书写元素时，一定要记得用括号封装它们。JSX 本质上会替换成函数，由于自动分号插 入机制的存在，另起一行的函数可能会导致意外结果。</p><p>以下示例可以正常运行，因为 div 元素和返回在同一行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return &lt;div /&gt;</span><br></pre></td></tr></table></figure></p><p>但接下来的示例就失效了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return</span><br><span class="line">  &lt;div /&gt;</span><br></pre></td></tr></table></figure></p><p>因为它会转换为以下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return;</span><br><span class="line">React.createElement(&quot;div&quot;, null);</span><br></pre></td></tr></table></figure></p><p>  因此你需要将代码语句包裹在括号内:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;div /&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="2"><li>多个属性的书写</li></ol><p>一种方案是将所有属性写在同一 行，但这样会使得一行代码变得特别长，我们不希望代码出现这种情况</p><p>常见的解决方案是一行书写一个属性，同时缩进一个层级，并保持结尾括号和开始标签 对齐:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  foo=&quot;bar&quot;</span><br><span class="line">  veryLongPropertyName=&quot;baz&quot;</span><br><span class="line">  onSomething=&#123;this.handleSomething&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>条件语句</li></ol><p>尽量简洁</p><p>三元运算符</p><p>对象的 getter 方法</p><p>render-if<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save render-if</span><br></pre></td></tr></table></figure></p><p>react-only-if</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-only-if</span><br></pre></td></tr></table></figure><ol start="4"><li>循环</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">      &#123;users.map(user =&gt;&lt;li&gt;&#123;user.name&#125;&lt;/li&gt;)&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>控制语句</li></ol><p>我们的目的是从组件中移除==所有逻辑==，尤其是渲染方法中的。但有时需要根据应 用的状态来显示或隐藏元素，经常还需要遍历集合与数组</p><p>Babel 插件: jsx-control-statements。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save jsx-control-statements</span><br></pre></td></tr></table></figure><p>安装完成后，将它添加到.babelrc 文件中的 Babel 插件列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [&quot;jsx-control-statements&quot;]</span><br></pre></td></tr></table></figure></p><p>接着就可以使用这个插件提供的语法了，Babel 会将它连同普通的 JSX 语法一同转译。</p><p>以下是使用该插件编写的条件语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;If condition=&#123;this.canShowSecretData&#125;&gt;</span><br><span class="line">  &lt;SecretData /&gt;</span><br><span class="line">&lt;/If&gt;</span><br></pre></td></tr></table></figure><p>它会转译为三元表达式，如下所示:</p><p>{canShowSecretData ? <secretdata> : null}</secretdata></p><p>If 组件非常有用，但如果渲染方法中需要嵌套条件，那么它很容易变得混乱且难以理解。</p><p>查看以下 Choose 组件的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Choose&gt;</span><br><span class="line">  &lt;When condition=&#123;...&#125;&gt;</span><br><span class="line">    &lt;span&gt;if&lt;/span&gt;</span><br><span class="line">  &lt;/When&gt;</span><br><span class="line">  &lt;When condition=&#123;...&#125;&gt;</span><br><span class="line">    &lt;span&gt;else if&lt;/span&gt;</span><br><span class="line">  &lt;/When&gt;</span><br><span class="line">  &lt;Otherwise&gt;</span><br><span class="line">    &lt;span&gt;else&lt;/span&gt;</span><br><span class="line">  &lt;/Otherwise&gt;</span><br><span class="line">&lt;/Choose&gt;</span><br></pre></td></tr></table></figure></p><p>  注意!上述代码会转译为多个三元表达式。</p><p>最后，我们介绍一个可以轻松实现循环的组件(记住，我们所提到的并非真实的组件，而只 是语法糖):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;For each=&quot;user&quot; of=&#123;this.props.users&#125;&gt;</span><br><span class="line">    &lt;li&gt;&#123;user.name&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/For&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>linter(一种代码检查工具)</p><p>为了避免代码检查时报错， 我们需要安装另一个插件:eslintplugin-jsx-control-statements</p><ol start="6"><li>次级渲染</li></ol><p>我们总是希望组件可以足够小，渲染方法也要简单明了</p><h2 id="2-2-ESLint"><a href="#2-2-ESLint" class="headerlink" title="2.2 ESLint"></a>2.2 ESLint</h2><h3 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1 安装"></a>2.2.1 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --global eslint</span><br><span class="line"></span><br><span class="line">eslint source.js</span><br></pre></td></tr></table></figure><p>输出结果会告诉我们文件中是否有错。</p><p>安装后首次运行不会看到任何报错，因为它各方面都需要配置，一开始并不包含任何默认规则。</p><h3 id="2-2-2-配置"><a href="#2-2-2-配置" class="headerlink" title="2.2.2 配置"></a>2.2.2 配置</h3><p>可以使用位于项目根目录的.eslintrc 文件来配置 ESLint。</p><p>略略略略略略略略略。。。。。</p><h3 id="2-2-3-React-插件"><a href="#2-2-3-React-插件" class="headerlink" title="2.2.3 React 插件"></a>2.2.3 React 插件</h3><h3 id="2-2-4-Airbnb-的配置"><a href="#2-2-4-Airbnb-的配置" class="headerlink" title="2.2.4 Airbnb 的配置"></a>2.2.4 Airbnb 的配置</h3><hr><h2 id="2-3-函数式编程基础"><a href="#2-3-函数式编程基础" class="headerlink" title="2.3 函数式编程基础"></a>2.3 函数式编程基础</h2><p>除了编写 JSX 时遵循最佳实践，并使用 linter 来加强代码一致性以更早发现错误</p><p>保持代码简洁的另一个方法是:遵循函数式编程风格。</p><h3 id="2-3-1-一等对象"><a href="#2-3-1-一等对象" class="headerlink" title="2.3.1 一等对象"></a>2.3.1 一等对象</h3><p>JavaScript 的函数是一等对象，这意味着它们可以赋给变量，也可以作为参数传递给其他函数。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>==高阶函数==接受一个函数作为参数，也可以传入其他参数， 最后返回另一个函数。返回的函数通常会添加一些增强的特殊行为</p><p>一个两数相加的函数在增强后先打印所有参数，再接着执行原先的逻辑:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const add = (x, y) =&gt; x + y</span><br><span class="line">    const log = func =&gt; (...args) =&gt; &#123;</span><br><span class="line">      console.log(...args)</span><br><span class="line">      return func(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    const logAdd = log(add)</span><br></pre></td></tr></table></figure><p>理解这个概念非常重要，因为 React 领域的一个常用模式是使用==高阶组件==，将组件当作函数， 并为它们增加一些常用行为。</p><h3 id="2-3-2-纯粹性"><a href="#2-3-2-纯粹性" class="headerlink" title="2.3.2 纯粹性"></a>2.3.2 纯粹性</h3><p>编写纯粹函数是函数式编程的一个重要方面。</p><p>函数的纯粹性到底指什么呢?</p><p>==纯粹函数==( 纯函数 )是指它不产生副作用，也就是说它不会改变自身作用域以外的任何东西。</p><p>举例来说，如果函数改变了应用状态、修改了上层作用域定义的变量，或者与 DOM 这样的 外部实体发生了交互，那么该函数就是非纯粹函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = (x, y) =&gt; x + y</span><br></pre></td></tr></table></figure><p>它可以运行多次，并且总能得到同样的结果，因为没有将数据存储在其他地方，也没有修改 任何东西。</p><p>非纯粹函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = 0</span><br><span class="line">const add = y =&gt; (x = x + y)</span><br></pre></td></tr></table></figure></p><p>执行 add(1)两次，但得到了两个不同的结果。第一次是 1，而第二次是 2，尽管我们是用同 样的参数调用同一个函数。出现这种情况的原因在于每次执行都修改了全局状态。</p><h3 id="2-3-3-不可变性"><a href="#2-3-3-不可变性" class="headerlink" title="2.3.3 不可变性"></a>2.3.3 不可变性</h3><p>在函数式编程中，函数不会修改变量值，而是创建新的变量，赋新值后再返回变量。操作数据的这种<br>方式称为==不可变性==。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const add3 = arr =&gt; arr.push(3)</span><br><span class="line">const myArr = [1, 2]</span><br><span class="line">add3(myArr) // [1, 2, 3]</span><br><span class="line">add3(myArr) // [1, 2, 3, 3]</span><br></pre></td></tr></table></figure></p><p>上述代码中的函数没有遵循不可变性，因为它修改了给定数组的值。另外，调用这个函数两 次会得到不同结果。</p><p>可以用 concat 方法改写以上函数，使其满足不可变性。concat 方法会返回新数组，而且 不会修改原数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const add3 = arr =&gt; arr.concat(3)</span><br><span class="line">const myArr = [1, 2]</span><br><span class="line">const result1 = add3(myArr) // [1, 2, 3]</span><br><span class="line">const result2 = add3(myArr) // [1, 2, 3]</span><br></pre></td></tr></table></figure></p><p>此时即便运行该函数两次，myArr 仍然保有初始值。</p><h3 id="2-3-4-柯里化"><a href="#2-3-4-柯里化" class="headerlink" title="2.3.4 柯里化"></a>2.3.4 柯里化</h3><p>柯里化过程就是将多参数函数转换成单参数函数，这些单 参数函数的返回值也是函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = (x, y) =&gt; x + y</span><br></pre></td></tr></table></figure></p><p>将其定义为以下写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = x =&gt; y =&gt; x + y</span><br></pre></td></tr></table></figure></p><p>然后按以下方式使用它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const add1 = add(1)</span><br><span class="line">add1(2) // 3</span><br><span class="line">add1(3) // 4</span><br></pre></td></tr></table></figure></p><p>这种函数写法相当方便，因为传入第一个参数后，第一个值被保留起来，返回的第二个函数 可以多次复用。</p><h3 id="2-3-5-组合"><a href="#2-3-5-组合" class="headerlink" title="2.3.5 组合"></a>2.3.5 组合</h3><p>函数(和组件)可以结合<br>产生新函数，从而提供更高级的功能与属性。</p><p>思考以下函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const add = (x, y) =&gt; x + y</span><br><span class="line">const square = x =&gt; x * x</span><br></pre></td></tr></table></figure></p><p>这两个函数可以组合创建一个新函数，用于两数相加，再对结果求平方:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const addAndSquare = (x, y) =&gt; square(add(x, y))</span><br></pre></td></tr></table></figure><p>遵循这个范式就可以编写小而简单、易于测试的纯粹函数，然后再将它们组合起来使用。</p><h3 id="2-3-6-函数式编程与-UI"><a href="#2-3-6-函数式编程与-UI" class="headerlink" title="2.3.6 函数式编程与 UI"></a>2.3.6 函数式编程与 UI</h3><p>如何用函数式编程构建 UI，这也正是使用 React 的目的。</p><p>可以将 UI 看作传入应用状态的函数，如下所示: UI = f(state)</p><p>我们希望这是一个幂等函数，即传入相同的应用状态时会返回同样的 UI。</p><p>组件可以组合形成最后的 UI，这也正是函数式编程的特性之一。</p><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p>本章介绍了大量有关 JSX 工作原理的内容，以及如何在组件中正确使用 JSX。我们从基础语法入手，奠定扎实基础以掌握 JSX 及其特性。</p><p>第二部分将介绍 ESLint 及其插件如何帮助我们更快发现错误，以及怎样在代码库中强制推行一致的风格指南。</p><p>最后，我们介绍了函数式编程的基础，以理解开发 React 应用所需要的重要概念。</p></label>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> react </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript开发者应懂的33个概念(一)</title>
      <link href="/2018/12/11/JavaScript%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E6%87%82%E7%9A%8433%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/12/11/JavaScript%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E6%87%82%E7%9A%8433%E4%B8%AA%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>调用堆栈</li><li>原始类型 </li><li>值类型和引用类型</li><li>隐式, 显式, 名义和鸭子类型</li><li>== 与 ===, typeof 与 instanceof</li><li>this, call, apply 和 bind</li><li>函数作用域, 块级作用域和词法作用域</li><li>闭包</li><li>map, reduce, filter 等高阶函数</li><li>表达式和语句</li><li>变量提升</li><li>Promise</li><li>立即执行函数, 模块化, 命名空间</li><li>递归</li><li>算法</li><li>数据结构</li><li>消息队列和事件循环</li><li>setTimeout, setInterval 和 requestAnimationFrame</li><li>继承, 多态和代码复用</li><li>按位操作符, 类数组对象和类型化数组</li><li>DOM 树和渲染过程</li><li>new 与构造函数, instanceof 与实例</li><li>原型继承与原型链</li><li>Object.create 和 Object.assign</li><li>工厂函数和类</li><li>设计模式</li><li>Memoization</li><li>纯函数, 函数副作用和状态变化</li><li>耗性能操作和时间复杂度</li><li>JavaScript 引擎</li><li>二进制, 十进制, 十六进制, 科学记数法</li><li>偏函数, 柯里化, Compose 和 Pipe</li><li>代码整洁之道</li></ul><ol><li>调用堆栈</li></ol><p>我的理解：首先我们需要理解代码执行的先后顺序，按照代码执行的先后顺序将将要执行的部分放入一个容器，<br>然后当这部分代码执行完之后，就在容器中删除这部分代码，最后接着执行代码中这部分代码后面的代码</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个调用堆栈，是一个解释的机制（如在Web浏览器中的JavaScript解释器）来跟踪其位置的调用多种脚本功能</p><ul><li>当脚本调用函数时，解释器将其添加到调用堆栈，然后开始执行该函数。</li><li>该函数调用的任何函数都会进一步添加到调用堆栈中，并在到达其调用的位置运行。</li><li>当前函数完成后，解释器将其从堆栈中取出并在最后一个代码清单中从中断处继续执行。</li><li>如果堆栈占用的空间超过分配给它的空间，则会导致“堆栈溢出”错误。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line">function printSquare(x) &#123;</span><br><span class="line">  var s = multiply(x, x);</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(5);</span><br></pre></td></tr></table></figure><p><a href="https://user-gold-cdn.xitu.io/2017/11/11/bc37a6231fca3b0aa3cd36369e866837?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener">image</a>;</p><h4 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><a href="https://user-gold-cdn.xitu.io/2017/11/11/3925f8363d7a763e6474709ccddf7d96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener">image</a></p><h4 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h4><p>JavaScript 引擎说起来最流行的当然是谷歌的 V8 引擎了， V8 引擎使用在 Chrome 以及 Node 中，下面有个简单的图能说明他们的关系：</p><p><a href="https://user-gold-cdn.xitu.io/2017/11/11/5d0653fff3ec904dbe210161f3ec9196?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener">image</a>;</p><p>这个引擎主要由两部分组成:</p><ul><li>内存堆：这是内存分配发生的地方</li><li>调用栈：这是你的代码执行时的地方</li></ul><ol start="2"><li>原始类型</li></ol><p>ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。</p><p>基本类型（基本数值、基本数据类型）是指非 对象 并且无方法的数据。</p><p>在 JavaScript 中，共有6种基本数据类型：string，number，boolean，null，undefined，symbol (ECMAScript 2015新增)。</p><ol start="3"><li>值类型和引用类型</li></ol><p>复杂数据类型全是引用类型，如：object，array</p><p>string、boolean、number是值类型</p><p>我的理解是，因为复杂数据类型在磁盘中所占的空间较大，所以像这种占空间较大的数据类型的值都是引用类型，而值类型一般所占空间不是特别大，所以这类的值将全部存储在磁盘中</p><p>我对引用类型的理解：引用类型就相当于指针，指针指向的就是源数据的存储在磁盘中的地址</p><ol start="4"><li>隐式, 显式, 名义和鸭子类型</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="string">''</span>)    <span class="comment">//隐式转换</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1</span>)   <span class="comment">//显式转换</span></span><br></pre></td></tr></table></figure><p>鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”</p><p>看起来像数组，那么它就是数组；看起来像对象，那么它就是对象。</p><ol start="5"><li>== vs ===, typeof 与 instanceof</li></ol><p>JavaScript提供三种不同的值比较操作：</p><ul><li>严格相等 (“triple equals” 或 “identity”)，使用 === ,</li><li>宽松相等 (“double equals”) ，使用 ==</li><li>以及 Object.is （ECMAScript 2015/ ES6 新特性）</li></ul><p>typeof方法返回一个字符串，来表示数据的类型。</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。</p><p>instanceof 左操作数是一个类，右操作数是标识对象的类。如果左侧的对象是右侧类的实例，则返回true；如果左操作数不是对象，则返回false,如果右操作数不是函数，则抛出typeError。</p><p>语法是object instanceof constructor</p><ol start="6"><li>this, call, apply 和 bind</li></ol><h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h4><ul><li>this 永远指向最后调用它的那个对象</li></ul><h4 id="怎么改变-this-的指向"><a href="#怎么改变-this-的指向" class="headerlink" title="怎么改变 this 的指向"></a>怎么改变 this 的指向</h4><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 _this = this</li><li>使用 apply、call、bind</li><li>new 实例化一个对象</li></ul><p>call 的第二个参数是一个参数列表</p><p>apply 的第二个参数必须是一个数组</p><p>bind和call类似，但不会执行对应的函数</p><p><a href="http://coopo.cc/2018/11/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3call,bind,apply%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">apply、call、bind详细介绍</a></p><ol start="7"><li>函数作用域, 块级作用域和词法作用域</li></ol><h4 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h4><p>作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）的规则</p><h4 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h4><p><a href="https://note.youdao.com/favicon.icohttps://user-gold-cdn.xitu.io/2018/5/16/16364a28627cc95b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener">image</a></p><p><a href="https://user-gold-cdn.xitu.io/2018/5/16/16364a2862881338?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener">image</a></p><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>所谓的词法作用域就是在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了。</p><p><a href="https://user-gold-cdn.xitu.io/2018/5/16/16364a28a034cb0e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener">image</a></p><ol start="8"><li>闭包</li></ol><p>闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。这时就可以将闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function makeAdder(x) &#123;</span><br><span class="line">  return function(y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add5 = makeAdder(5);</span><br><span class="line">var add10 = makeAdder(10);</span><br><span class="line"></span><br><span class="line">console.log(add5(2));  // 7</span><br><span class="line">console.log(add10(2)); // 12</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建</span><br><span class="line">var module = (function()&#123;</span><br><span class="line">                var privateName = &apos;inner&apos;;            //私有变量</span><br><span class="line">                var privateFunc = function()&#123;        //私有函数</span><br><span class="line">                    console.log(&apos;私有函数&apos;)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return &#123;                            </span><br><span class="line">                    name: &apos;rouwan&apos;,                    //公有属性</span><br><span class="line">                    sayName:function()&#123;                //公有函数</span><br><span class="line">                        console.log(this.name)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)()</span><br><span class="line">//使用</span><br><span class="line">module.sayName();    //&apos;rouwan&apos;</span><br></pre></td></tr></table></figure><h3 id="思考题目"><a href="#思考题目" class="headerlink" title="思考题目"></a>思考题目</h3><p>转载自<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">阮一峰博客</a>，出自《JavaScript高级程序设计》</p><h4 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;;</span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line">运行结果：The  Window</span><br></pre></td></tr></table></figure><p>解释：object.getNameFunc()这是属于方法调用，this指针指向的是object，可以用一个变量tmp引用它的结果，实际上tmp就是这个方法返回的那个匿名函数function(){return this.name;};，此时并没有执行内部代码，执行tmp()时，也就是object.getNameFunc()()时，this指针指向window，最终返回The Window。</p><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;;</span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line">运行结果：My Object</span><br></pre></td></tr></table></figure><p>解释：在调用getNameFunc()时，属于方法调用，那么this指针指向object，把它被that引用，那么返回的匿名函数中时刻保持对object的引用，很好理解。</p><ol start="9"><li>map, reduce, filter 等高阶函数</li></ol><ul><li>filter</li></ul><p>filter((item,index)=&gt;{ 筛选 })，数组的筛选功能</p><ul><li>map</li></ul><p>map((item,index)=&gt;{ 修改 })，根据函数的内容对数组进行修改</p><ul><li>reduce</li></ul><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/reduce1.png" alt="image"><br><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/reduce2.png" alt="image"></p><p>让数组的前项和后项做计算，并累计最终值</p><p><a href="http://coopo.cc/2018/12/05/JS%E4%B8%ADreduce%E7%9A%84%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">详细使用</a>;</p><ol start="10"><li>表达式和语句</li></ol><p>-表达式</p><p>一个表达式返回一个值，可以在任何需要值的地方使用表达式，例如：作为函数调用时使用的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myvar</span><br><span class="line"></span><br><span class="line">3 + x</span><br><span class="line"></span><br><span class="line">myfunc(&quot;a&quot;, &quot;b&quot;)</span><br></pre></td></tr></table></figure><ul><li>语句</li></ul><p>我们可以粗略的将一个语句描述为一个行为。循环结构和if语句就是语句的例子</p><p>JavaScript需要编写一条语句时，均可以写入一个表达式。这样的语句称为表达式语句</p><ol start="11"><li>变量提升</li></ol><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p><p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = 5; // 变量 x 设置为 5</span><br><span class="line"></span><br><span class="line">elem = document.getElementById(&quot;demo&quot;); // 查找元素</span><br><span class="line">elem.innerHTML = x;                     // 在元素中显示 x</span><br><span class="line"></span><br><span class="line">var x; // 声明 x</span><br></pre></td></tr></table></figure><p>变量提升将会把：var x  提升到函数的最顶部</p><ol start="12"><li>Promise</li></ol><p>一个 Promise 就是一个代表了异步操作最终完成或者失败的对象。大多数人都在使用由其他函数创建并返回的 Promise</p><p>Promise 本质上是一个绑定了回调的对象，而不是将回调传进函数内部</p><ul><li><p>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</p></li><li><p>通过 .then 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用，如上所示。</p></li><li><p>通过多次调用 .then，可以添加多个回调函数，它们会按照插入顺序并且独立运行。</p></li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>resolve</li></ul><p>成功的回调</p><ul><li>reject</li></ul><p>失败的回调</p><ol start="13"><li>立即执行函数, 模块化, 命名空间</li></ol><p>匿名函数自执行（闭包），闭包可以形成私有变量和函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建</span><br><span class="line">var module = (function()&#123;</span><br><span class="line">                var privateName = &apos;inner&apos;;            //私有变量</span><br><span class="line">                var privateFunc = function()&#123;        //私有函数</span><br><span class="line">                    console.log(&apos;私有函数&apos;)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return &#123;                            </span><br><span class="line">                    name: &apos;rouwan&apos;,                    //公有属性</span><br><span class="line">                    sayName:function()&#123;                //公有函数</span><br><span class="line">                        console.log(this.name)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)()</span><br><span class="line">//使用</span><br><span class="line">module.sayName();    //&apos;rouwan&apos;</span><br></pre></td></tr></table></figure><p>前端模块化，主要是解决两个问题——“命名空间冲突”，“文件依赖管理”。</p><p>命名空间：各个模块的命名空间独立。A模块的变量x不会覆盖B模块的变量x。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>express文件上传中间件Multer最新使用说明</title>
      <link href="/2018/12/06/express%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%AD%E9%97%B4%E4%BB%B6Multer%E6%9C%80%E6%96%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/12/06/express%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%AD%E9%97%B4%E4%BB%B6Multer%E6%9C%80%E6%96%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>本文转自：</p><p><a href="http://cnodejs.org/topic/564f32631986c7df7e92b0db" target="_blank" rel="noopener">http://cnodejs.org/topic/564f32631986c7df7e92b0db</a></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>multer是express官方推荐的文件上传中间件，它是在busboy的基础上开发的。目前multer的最新版本为：~1.1.0。本文所有代码段均使用此版本。multer的官方地址：<a href="https://github.com/expressjs/multer" target="_blank" rel="noopener">GitHub</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在nodejs下的package.json中添加multer依赖，运行加载依赖库。新建multerUtil.js,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> var  multer=require(&apos;multer&apos;);</span><br><span class="line"> var storage = multer.diskStorage(&#123;</span><br><span class="line">     //设置上传后文件路径，uploads文件夹会自动创建。</span><br><span class="line">        destination: function (req, file, cb) &#123;</span><br><span class="line">            cb(null, &apos;./public/uploads&apos;)</span><br><span class="line">       &#125;,</span><br><span class="line">     //给上传文件重命名，获取添加后缀名</span><br><span class="line">      filename: function (req, file, cb) &#123;</span><br><span class="line">          var fileFormat = (file.originalname).split(&quot;.&quot;);</span><br><span class="line">          cb(null, file.fieldname + &apos;-&apos; + Date.now() + &quot;.&quot; + fileFormat[fileFormat.length - 1]);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;);  </span><br><span class="line">     //添加配置文件到muler对象。</span><br><span class="line">     var upload = multer(&#123;</span><br><span class="line">          storage: storage</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">//如需其他设置，请参考multer的limits,使用方法如下。</span><br><span class="line">   //var upload = multer(&#123;</span><br><span class="line">  //    storage: storage,</span><br><span class="line">  //    limits:&#123;&#125;</span><br><span class="line">  // &#125;);</span><br><span class="line"></span><br><span class="line"> //导出对象</span><br><span class="line">module.exports = upload;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>testController.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var muilter = require(&apos;./multerUtil&apos;);</span><br><span class="line">        //multer有single()中的名称必须是表单上传字段的name名称。</span><br><span class="line"> var upload=muilter.single(&apos;file&apos;);          </span><br><span class="line">      exports.dataInput = function (req, res) &#123;</span><br><span class="line">      upload(req, res, function (err) &#123;</span><br><span class="line">        //添加错误处理</span><br><span class="line">    if (err) &#123;</span><br><span class="line">         return  console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">        //文件信息在req.file或者req.files中显示。</span><br><span class="line">    console.log(req);</span><br><span class="line">  &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var testController=require(&apos;./testController&apos;);</span><br><span class="line">app.post(&apos;/dataInpute&apos;,testController.dataInput);</span><br></pre></td></tr></table></figure><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>1.文件上传有以下方法</p><ul><li>muilter.single(‘file’)</li></ul><p>适用于单文件上传</p><ul><li>muilter.array(‘file’,num),</li></ul><p>适用于多文件上传，num为最多上传个数，上传文件的数量可以小于num,</p><p>muilter.fields(fields),</p><p>适用于混合上传，比如A类文件1个，B类文件2个。官方API有详细说明。</p><p>2.file为上传字段名称，当使用form表单submit方式上传时，必须与表单上传的name属性保持一致。</p><p>表单记得加上enctype=‘multipart/form-data’</p><p>3.对上传文件大小限制，名称限制等均可在limits中加上，具体可加属性，请参考官方api。</p>]]></content>
      
      
      
        <tags>
            
            <tag> express </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> fs </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中reduce的用法</title>
      <link href="/2018/12/05/JS%E4%B8%ADreduce%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2018/12/05/JS%E4%B8%ADreduce%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce 方法"></a>reduce 方法</h2><ul><li>对数组中的所有元素调用指定的回调函数。</li><li>该回调函数的返回值为累积结果，并且此返回值在下一次调用该回调函数时作为参数提供。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>array1.reduce(callbackfn[, initialValue])</p><ul><li>array1       必需。一个数组对象。</li><li>callbackfn 必需。一个接受最多四个参数的函数。</li><li>initialValue 可选。如果指定initialValue，则它将用作初始值来启动累积。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>通过最后一次调用回调函数获得的累积结果。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>当满足下列任一条件时，将引发 TypeError 异常：</p><ul><li>callbackfn 参数不是函数对象。</li><li>数组不包含元素，且未提供 initialValue。</li></ul><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li>如果提供了 initialValue，则 reduce 方法会对数组中的每个元素调用一次 callbackfn 函数（按升序索引顺序）。</li><li>如果未提供 initialValue，则 reduce 方法会对从第二个元素开始的每个元素调用 callbackfn 函数。</li></ul><h3 id="回调函数语法"><a href="#回调函数语法" class="headerlink" title="回调函数语法"></a>回调函数语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function callbackfn(previousValue, currentValue, currentIndex, array1)</span><br></pre></td></tr></table></figure><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/reduce1.png" alt="image"><br><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/reduce2.png" alt="image"></p><h4 id="栗子1：将数组元素变成字符串拼接"><a href="#栗子1：将数组元素变成字符串拼接" class="headerlink" title="栗子1：将数组元素变成字符串拼接"></a>栗子1：将数组元素变成字符串拼接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function lizi1(prev,curr)&#123;</span><br><span class="line">      return prev+&apos;::&apos;+curr;</span><br><span class="line">  &#125;</span><br><span class="line">  var arr1=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">  var result1= arr1.reduce(lizi1);</span><br><span class="line">   console.info(&apos;result1&apos;,arr1.reduce(lizi1)); //输出</span><br></pre></td></tr></table></figure><p>箭头函数写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var rs1 = arr1.reduce((prev,cur) =&gt;&#123;</span><br><span class="line">      return prev+&apos;::&apos; +cur</span><br><span class="line">  &#125;)</span><br><span class="line">  console.info(&apos;rs1&apos;,rs1);</span><br></pre></td></tr></table></figure><h4 id="栗子2：扁平化二维数组"><a href="#栗子2：扁平化二维数组" class="headerlink" title="栗子2：扁平化二维数组"></a>栗子2：扁平化二维数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//传initialVal,扁平化二维数组</span><br><span class="line">    function lizi2(prev,curr)&#123;</span><br><span class="line">        return prev.concat(curr)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var arr2=[[1,2],[3,4],[5,6],[7]]</span><br><span class="line">  // 传initValue</span><br><span class="line">  var result2 = arr2.reduce(lizi2,[]);</span><br><span class="line">console.info(&apos;result2&apos;,result2);//输出 [1,2,3,4,5,6,7]</span><br><span class="line">  //不传initValue</span><br><span class="line">  var result3 = arr2.reduce(lizi2);</span><br><span class="line"></span><br><span class="line"> console.info(&apos;result3&apos;,result3);//输出 [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure><p>箭头函数写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var rs2 = arr2.reduce((a, b) =&gt; &#123;</span><br><span class="line">      return a.concat(b)</span><br><span class="line">  &#125;,[])</span><br></pre></td></tr></table></figure><h4 id="栗子3：处理数据并，累加"><a href="#栗子3：处理数据并，累加" class="headerlink" title="栗子3：处理数据并，累加"></a>栗子3：处理数据并，累加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function absolute(prev,curr)&#123;</span><br><span class="line">        return Math.abs(prev)+Math.abs(curr)</span><br><span class="line">    &#125;</span><br><span class="line">    var arr4 = [-2];</span><br><span class="line">    //不传initVal,观察差别</span><br><span class="line">    var result4 = arr4.reduce(absolute);</span><br><span class="line">    //传initVal,</span><br><span class="line">    var result5 = arr4.reduce(absolute,0);</span><br><span class="line">    console.info(&apos;result4&apos;,result4) //-2</span><br><span class="line">    console.info(&apos;result5&apos;,result5) //2</span><br></pre></td></tr></table></figure><h4 id="栗子4：取数组中大于1并小于10的元素"><a href="#栗子4：取数组中大于1并小于10的元素" class="headerlink" title="栗子4：取数组中大于1并小于10的元素"></a>栗子4：取数组中大于1并小于10的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function process(prevArray,curr)&#123;</span><br><span class="line">        var arr = null;</span><br><span class="line">        if(curr &gt;1 &amp;&amp;curr &lt; 10)&#123;</span><br><span class="line">            arr = prevArray.concat(curr)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            arr = prevArray</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var arr5 = [100,20,3,4,-5,10,2,-3,9];</span><br><span class="line">    var result6 = arr5.reduce(process,[]);</span><br><span class="line">    console.info(&apos;result6&apos;,result6) //[3,4,2,9]</span><br></pre></td></tr></table></figure><p>箭头函数写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var rs6 = arr5.reduce((prev,cur) =&gt; &#123;</span><br><span class="line">       var newArr;</span><br><span class="line">       if(cur&gt;1&amp;&amp;cur&lt;10)&#123;</span><br><span class="line">           newArr = prev.concat(cur)</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           newArr = prev</span><br><span class="line">       &#125;</span><br><span class="line">       return newArr</span><br><span class="line">    &#125;,[])</span><br></pre></td></tr></table></figure><h4 id="栗子5：将-1-3-1-4-转为数字1314"><a href="#栗子5：将-1-3-1-4-转为数字1314" class="headerlink" title="栗子5：将[1,3,1,4]转为数字1314"></a>栗子5：将[1,3,1,4]转为数字1314</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function addDigitValue(prev,curr,curIndex,array)&#123;</span><br><span class="line">        var exponent = (array.length -1) -curIndex;</span><br><span class="line">        var digitValue = curr*Math.pow(10,exponent);</span><br><span class="line">        return prev + digitValue;</span><br><span class="line">    &#125;</span><br><span class="line">     var arr6 = [1,3,1,4];</span><br><span class="line">     var result7 = arr6.reduce(addDigitValue,0)</span><br><span class="line">    console.info(&apos;result7&apos;,result7)</span><br></pre></td></tr></table></figure><p>本文摘自：</p><p><a href="https://www.cnblogs.com/lizimeme/p/7743742.html" target="_blank" rel="noopener">https://www.cnblogs.com/lizimeme/p/7743742.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> jascript </tag>
            
            <tag> reduce </tag>
            
            <tag> 数组方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通用上传组件设计</title>
      <link href="/2018/12/04/%E9%80%9A%E7%94%A8%E4%B8%8A%E4%BC%A0%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/12/04/%E9%80%9A%E7%94%A8%E4%B8%8A%E4%BC%A0%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="通用上传组件设计"><a href="#通用上传组件设计" class="headerlink" title="通用上传组件设计"></a>通用上传组件设计</h1><p><img src="http://webooxx.com/ddemo/fileUpload/design.png" alt="image"></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>这是一个通用的、文件上传功能公用的组件，在业务逻辑中，必要的时候（需要上传的时候）调用fileUpload的API</p><p>该组件的返回值是一个Promise对象，值是上传的文件后得到的相应的路径</p><h2 id="怎么用的"><a href="#怎么用的" class="headerlink" title="怎么用的"></a>怎么用的</h2><p>这个组件分为三大模块</p><ol><li>客户端应用（app）</li></ol><p>这部分主要讲的是该组件（fileUpload）怎么调用。</p><p>fileUpload中传入一个参数，这个参数是必须的，值是服务端地址，返回值是Promise对象，值是上传的文件后得到的相应的路径</p><ol start="2"><li>上传组件服务端</li><li>上传组件客户端</li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="上传组件服务端"><a href="#上传组件服务端" class="headerlink" title="上传组件服务端"></a>上传组件服务端</h3><p>处理文件上传到的服务端，里面包含了两个接口</p><ol><li>上传 /upload</li></ol><p>这个接口是上传文件的接口，文件通过ajax上传时，post的第一个参数就是这个接口</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ol><li>通过multer组件从请求中获取文件</li><li>使用fs模块为文件生成一个新的路径（$path$）</li><li>在这个相应的路径中写入该文件</li><li>将这个新的路径返回给客户端</li></ol><hr><ol start="2"><li>下载 /file/$path$</li></ol><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>这个接口是读取文件的接口，当客户端接收到服务端返回的新的路径的时候，客户端会根据这个新的路径再次向服务端发起请求，获取该路径对应的图片</p><h3 id="上传组件客户端"><a href="#上传组件客户端" class="headerlink" title="上传组件客户端"></a>上传组件客户端</h3><p>该部分主要作用是提供一个接口：fileUpload，其返回的是一个Promise对象，该对象的值是上传的文件后得到的相应的路径</p><ul><li>前端操作逻辑</li></ul><ol><li>初始化一个input.file，插入到body中</li><li>设置input的onchange事件处理函数</li><li>选择文件完成后将主动触发它的onchange事件处理函数</li></ol><ul><li>input  onchange  详细逻辑</li></ul><ol><li>获取上传的文件对象</li><li>初始化FormData对象</li><li>初始化ajax</li><li>ajax提交</li><li>ajax返回完成后执行Promise.resolve（xhr.responseText）</li></ol><hr><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>客户端应用 -&gt; 上传组件客户端 —&gt; 上传组件服务端 -&gt; 客户端应用</p><p>客户端应用（app）调用上传组件客户端的api，而该api返回的Promise对象的值是其于服务端发送请求后得到的数据，然后客户端应用又接收到了该数据，形成了一个闭环</p><h2 id="开发验证"><a href="#开发验证" class="headerlink" title="开发验证"></a>开发验证</h2><p>a. 初步验证,文件获取测试（最终确认api的调用方式、fileinput 可以被js设置&amp;触发点击、js可以获取用户的文件数据）</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/test%20%E4%B8%8B%E5%8D%887.00.45.jpg" alt="image"></p><p>从这张图可以看出，通过点击fileinput，根据alert的内容，可以确认获取到了文件和文件属性之类的</p><hr><p>b. 验证文件通过Ajax提交（最终确认可以用ajax将文件内容发送到服务端）</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/ajax.jpg" alt="image"></p><p>c. 验证服务端文件获取（最终确认ajax发送到服务端的内容可以被获取，fileinput 的name与服务端获取内容的关系）</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/first.jpg" alt="image"></p><p>服务端代码：log出req.file</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/ok.jpg" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multer.single(‘file’), //适用于单文件上传</span><br><span class="line">multer.array(‘file’,num), //适用于多文件上传，num为最多上传个数，上传文件的数量可以小于num,</span><br><span class="line">multer.fields(fields), //适用于混合上传，比如A类文件1个，B类文件2个。官方API有详细说明。</span><br></pre></td></tr></table></figure><p>从这则资料，可以知道，input.file的name与服务端multer.single(‘file’)中的参数对应，只是为了服务端获取文件</p><p>d. 验证文件写入（最终确认文件按照代码所示，写入到了指定文件）</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/files.jpg" alt="image"></p><p>e. 验证读取模块（最终确认文件写入路径可以被反向的读取出来，阐述下写入路径和读取路径的关系）</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/src.jpg" alt="image"></p><hr><p>课外知识：multer（中间件）</p><p>Multer 在解析完请求体后，会向 request 对象添加一个body对象和一个file或者files对象（上传多个文件时使用files对象）。其中body对象包含所提交表单中的文本字段（如果有），而file（或files）对象中包含通过表单上传的文件。  </p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ajax </tag>
            
            <tag> FormData </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS特效-黑客帝国矩阵</title>
      <link href="/2018/12/04/JS%E7%89%B9%E6%95%88-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD%E7%9F%A9%E9%98%B5/"/>
      <url>/2018/12/04/JS%E7%89%B9%E6%95%88-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>简直不是我等凡人能理解的。。js代码仅有 308 个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(s=window.screen,w=q.width=s.width,h=q.height=s.height,m=Math.random,p=[],i=0;i&lt;256;p[i++]=1);setInterval(&apos;9Style=\&apos;rgba(0,0,0,.05)\&apos;9Rect(0,0,w,h)9Style=\&apos;#0F0\&apos;;p.map(function(v,i)&#123;9Text(String.fromCharCode(3e4+m()*33),i*10,v);p[i]=v&gt;758+m()*1e4?0:v+10&#125;)&apos;.split(9).join(&apos;;q.getContext(\&apos;2d\&apos;).fill&apos;),33)</span><br></pre></td></tr></table></figure><p><a href="http://webooxx.com/rdemo/matrix.html" target="_blank" rel="noopener">效果预览</a></p><p>本文摘自<br><a href="http://webooxx.com/2014/05/30/JS%E7%89%B9%E6%95%88-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">http://webooxx.com/2014/05/30/JS%E7%89%B9%E6%95%88-%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD%E7%9F%A9%E9%98%B5/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 一行代码 </tag>
            
            <tag> 特效 </tag>
            
            <tag> 黑客帝国 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FormData用法详解</title>
      <link href="/2018/12/02/FormData%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/12/02/FormData%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="FormData用法详解"><a href="#FormData用法详解" class="headerlink" title="FormData用法详解"></a>FormData用法详解</h1><p>FormData 对象：</p><p><img src="https://sfault-image.b0.upaiyun.com/203/933/2039338818-5a28f425ab032_articlex" alt="image"></p><h2 id="创建一个formData对象实例的方式"><a href="#创建一个formData对象实例的方式" class="headerlink" title="创建一个formData对象实例的方式"></a>创建一个formData对象实例的方式</h2><ol><li>创建一个空对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var formData = new FormData();//通过append方法添加数据</span><br></pre></td></tr></table></figure><ol start="2"><li>使用已有表单来初始化对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//表单示例</span><br><span class="line">&lt;form id=&quot;myForm&quot; action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;名字</span><br><span class="line">    &lt;input type=&quot;password&quot; name=&quot;psw&quot;&gt;密码</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">//方法示例</span><br><span class="line">// 获取页面已有的一个form表单</span><br><span class="line">var form = document.getElementById(&quot;myForm&quot;);</span><br><span class="line">// 用表单来初始化</span><br><span class="line">var formData = new FormData(form);</span><br><span class="line">// 我们可以根据name来访问表单中的字段</span><br><span class="line">var name = formData.get(&quot;name&quot;); // 获取名字</span><br><span class="line">var psw = formData.get(&quot;psw&quot;); // 获取密码</span><br><span class="line">// 当然也可以在此基础上，添加其他数据</span><br><span class="line">formData.append(&quot;token&quot;,&quot;kshdfiwi3rh&quot;);</span><br></pre></td></tr></table></figure><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>formData里面存储的数据是以健值对的形式存在的，key是唯一的，一个key可能对应多个value。<br>如果是使用表单初始化，每一个表单字段对应一条数据，它们的HTML name属性即为key值，它们value属性对应value值。</p><p>1.获取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通过get(key)/getAll(key)来获取对应的value</span><br><span class="line">formData.get(&quot;name&quot;); // 获取key为name的第一个值</span><br><span class="line">formData.get(&quot;name&quot;); // 返回一个数组，获取key为name的所有值</span><br></pre></td></tr></table></figure><ol start="2"><li>添加数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//通过append(key, value)来添加数据，如果指定的key不存在则会新增一条数据，如果key存在，则添加到数据的末尾</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v1&quot;);</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v2&quot;);</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v3&quot;);</span><br></pre></td></tr></table></figure><p>获取值时方式及结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formData.get(&quot;k1&quot;); // &quot;v1&quot;</span><br><span class="line">formData.getAll(&quot;k1&quot;); // [&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;]</span><br></pre></td></tr></table></figure><ol start="3"><li>设置修改数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//set(key, value)来设置修改数据，如果指定的key不存在则会新增一条，如果存在，则会修改对应的value值</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v1&quot;);</span><br><span class="line">formData.set(&quot;k1&quot;, &quot;1&quot;);</span><br><span class="line">formData.getAll(&quot;k1&quot;); // [&quot;1&quot;]</span><br></pre></td></tr></table></figure><ol start="4"><li>判断是否存在对应数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//has(key)来判断是否对应的key值</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v1&quot;);</span><br><span class="line">formData.append(&quot;k2&quot;,null);</span><br><span class="line"></span><br><span class="line">formData.has(&quot;k1&quot;); // true</span><br><span class="line">formData.has(&quot;k2&quot;); // true</span><br><span class="line">formData.has(&quot;k3&quot;); // false</span><br></pre></td></tr></table></figure><ol start="5"><li>删除数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//delete(key)删除数据</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v1&quot;);</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v2&quot;);</span><br><span class="line">formData.append(&quot;k1&quot;, &quot;v1&quot;);</span><br><span class="line">formData.delete(&quot;k1&quot;);</span><br><span class="line"></span><br><span class="line">formData.getAll(&quot;k1&quot;); // []</span><br></pre></td></tr></table></figure><h2 id="JQuery实例"><a href="#JQuery实例" class="headerlink" title="JQuery实例"></a>JQuery实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//添加数据方式见上二。</span><br><span class="line">//processData: false, contentType: false,多用来处理异步上传二进制文件。</span><br><span class="line"> $.ajax(&#123;</span><br><span class="line">    url: &apos;xxx&apos;,</span><br><span class="line">    type: &apos;POST&apos;,</span><br><span class="line">    data: formData,                    // 上传formdata封装的数据</span><br><span class="line">    dataType: &apos;JSON&apos;,</span><br><span class="line">    cache: false,                      // 不缓存</span><br><span class="line">    processData: false,                // jQuery不要去处理发送的数据</span><br><span class="line">    contentType: false,                // jQuery不要去设置Content-Type请求头</span><br><span class="line">    success:function (data) &#123;           //成功回调</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>附：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将以base64的图片url数据转换为Blob文件格式</span><br><span class="line"> * @param urlData 用url方式表示的base64图片</span><br><span class="line"> */</span><br><span class="line">function convertBase64UrlToBlob(urlData) &#123;</span><br><span class="line">    var bytes = window.atob(urlData.split(&apos;,&apos;)[1]); //去掉url的头，并转换为byte</span><br><span class="line">    //处理异常,将ascii码小于0的转换为大于0</span><br><span class="line">    var ab = new ArrayBuffer(bytes.length);</span><br><span class="line">    var ia = new Uint8Array(ab);</span><br><span class="line">    for(var i = 0; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        ia[i] = bytes.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Blob([ab], &#123;</span><br><span class="line">        type: &apos;image/png&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容摘自 <a href="https://segmentfault.com/a/1190000006716454" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006716454</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
            <tag> js </tag>
            
            <tag> ajax </tag>
            
            <tag> FormData </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客界面崩溃问题（无样式）</title>
      <link href="/2018/11/28/%E5%8D%9A%E5%AE%A2%E7%95%8C%E9%9D%A2%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%EF%BC%88%E6%97%A0%E6%A0%B7%E5%BC%8F%EF%BC%89/"/>
      <url>/2018/11/28/%E5%8D%9A%E5%AE%A2%E7%95%8C%E9%9D%A2%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%EF%BC%88%E6%97%A0%E6%A0%B7%E5%BC%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="博客界面崩溃问题（无样式）"><a href="#博客界面崩溃问题（无样式）" class="headerlink" title="博客界面崩溃问题（无样式）"></a>博客界面崩溃问题（无样式）</h1><p>作为程序猿我相信很多小伙伴都有属于自己的技术型博客，博客相当于日记本，要天天更新它才能显示它的新颖和价值</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>本人最近发现我的博客每当更新内容之后博客界面就会出现异常情况：无样式，排列布局很混乱。类似于这样</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/blog.jpg" alt="image"></p><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>没错，刚一开始我是一脸懵逼的，为什么一会没问题，一会又蹦出个没样式的问题呢？</p><p>于是我并没有想太多，直接去查看我github中存储我博客中所有文件的库，发现我css样式是15天前更新的</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/github.jpg" alt="image"></p><p>我就想是不是我所有css样式都没有更新上去，但假如就算没更新上去也有以前的css啊</p><p>虽然没有得到什么结果，但我没有放弃。我立即去问了一下我技术大佬的哥怎么回事，他给出了一个猜想：是不是没有清除浏览器的缓存。于是我便去清除了一下chrome的缓存，依然无样式，事实证明这个猜想不成立。</p><p>于是我陷入了死胡同……</p><p>无意间我打开控制台发现了重大的关键信息：</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/wrong.jpg" alt="image"></p><p>我立马提着这个问题去见了度娘，发现了这个报错的原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERR_CERT_COMMON_NAME_INVALID就是用一个错误的域名访问了某个节点的https资源。</span><br></pre></td></tr></table></figure><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>虽然并没有得到问题的根本所在，但这个结果又让我重新奋起，理清头绪重新来过。</p><p>根据上面得到的信息，我去看了一下我博客的源码，发现css引用的路径都是类似于这种：”/css/SimpleStyle.min.css”</p><p>也就是说我博客引用取的css样式路径是这样的：<a href="http://coopo.cc//css/SimpleStyle.min.css" target="_blank" rel="noopener">http://coopo.cc//css/SimpleStyle.min.css</a></p><p>在这之后我并没有做其他的是，而是回忆了一下一般一个完整的URL地址包括哪些内容?于是我在控制台输入了location，回车，展开发现了以下关键内容：</p><ul><li>hash</li><li>host</li><li>hostname</li><li>href</li><li>origin</li><li>pathname</li><li>port</li><li>protocol</li><li>search</li></ul><p>衍生知识结束后我立即做出了猜想：是不是我的css样式路径有问题？</p><p>于是我在控制台中，试着打开报错的css文件，发现一下问题</p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/main.jpg" alt="image"></p><p>哎呀我去，这不是强制打开https网站才会出现的提示嘛，于是我做了以下操作：点击高级 -&gt; 点击（继续前往coopo.cc（不安全））；</p><p>发现可以看到css的源码，但是作为小白的我依然得不到什么结论。最后当我发现问题根本所在的时候，发现我的逻辑思维能力还是解决问题能力都好弱（弱鸡）</p><p>我本想再次尝试重新分析问题，然后刷新一下页面，发现博客界面竟然正常显示，也有样式。哎呀，这好比写代码，在键盘上一顿乱敲，无意间得到了结果。这时我心里好像有一万只草泥马在奔腾。</p><p>我知道，这不算解决问题，问题也并没有解决，于是…</p><p>我又去请教我的大神老哥，他给出了一下提示：</p><p>1.打开Safari浏览器再次查看控制台可能问题就清晰了</p><p>2.你博客请求的css文件的url的协议名是https</p><h2 id="再次猜想"><a href="#再次猜想" class="headerlink" title="再次猜想"></a>再次猜想</h2><p>不可能啊，我的域名是<a href="http://coopo.cc" target="_blank" rel="noopener">http://coopo.cc</a> ; 就算是里面的引用的文件路径的协议名应该也是http啊，为什么会变为https：难道是我请求css文件的时候升级了协议（http-&gt;https）;</p><h2 id="证明猜想"><a href="#证明猜想" class="headerlink" title="证明猜想"></a>证明猜想</h2><p>打开控制台，发现还真是：Upgrade-Insecure-Requests: 1，我查了一下这段请求头中的字段是什么意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">该指令用于让浏览器自动升级请求从http到https,用于大量包含</span><br><span class="line">http资源的http网页直接升级到https而不会报错.简洁的来讲,</span><br><span class="line">就相当于在http和https之间起的一个过渡作用.</span><br></pre></td></tr></table></figure><p>猜想成立…</p><p>然而我在代码中并没有写任何关于升级协议的代码啊，于是我再次打开源代码，发现了其中包含了这段标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>再次搜索这段代码是干什么用的，得到一个结果：</p><p>在html的头部加入meta使得所有的资源请求由http请求转成https请求</p><p>感觉这次不会再出错了，我于是立即删掉这段代码重新部署了一下我的博客，在浏览器地址栏中输入：<a href="http://coopo.cc" target="_blank" rel="noopener">http://coopo.cc</a></p><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/blg.jpg" alt="image"></p><p>问题解决了，欧耶！！！</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>回想一下，原来我一直都在绕圈子。</p><p>当我在点击信任css文件查看其源码的时候，我应该看一下地址栏的；</p><ul><li>地址栏中该css文件是以https开头的</li></ul><p>我应该推测到我请求的是以http为协议名的css文件，而我却只有访问以https为协议名的css路径才能查看得到其源码</p><p>也就是说我请求css文件的时候，浏览器将我的http协议升级成了https协议</p><p>然后查看控制台中http报文中的内容我相信我应该可以独立解决这个问题。</p><p>当然这只是我解决问题之后的想法，问题当然只有碰到过，解决过才会感到简单</p><h3 id="大胆猜想，小心证明"><a href="#大胆猜想，小心证明" class="headerlink" title="大胆猜想，小心证明"></a>大胆猜想，小心证明</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 博客 </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件设计模式</title>
      <link href="/2018/11/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><p>为什么要提倡”Design Pattern”呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？OO界有前辈的几个原则：”开－闭”原则(Open Closed Principal)、里氏代换原则、合成复用原则。设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1.什么是设计模式</p><p>答：设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p><p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。可以针对某一系列问题提供一个实现的思想，框架，让设计条理清晰。</p><p>2.为什么需要设计模式</p><p>答：设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。因此，我们需要设计模式来解决复杂问题，使得分析问题更加明了，增强代码的可读性。</p><p>如果不使用设计模式对于简单的代码并没有什么影响，当代码长度过长的时候，不使用设计模式会使得代码晦涩难懂，缺乏可读性。运用设计模式让代码分块，更容易管理。</p><p>3.设计模式能给我们带来什么</p><p>答： 首先能给我们带来解决一类问题的基本思路，让实现起来更加清晰，并且设计完成之后，代码可重用性高。并且由于设计模式要遵循开闭原则，让后期代码维护也更加简单。最后要说的一点是，设计模式让使用者考虑问题养成从整体到局部的实现顺序，使得完成的更加顺利，合理运用类图使得实现简便。</p><p>4.设计模式学习面临的困难和解决思路</p><p>答： 设计模式初学起来会有些困难，因为模式种类多样，要去分别理解，而且设计模式还要遵循开闭等原则，学习初期可能会有点问题。并且设计模式采用的是自顶向下的设计方法，通过类图来做一个整体的构思，如果设计不好可能会对之后的实现造成困难。要想解决这些问题，首先要有钻研的精神，肯用功，要弄清楚这么多种设计模式的基本思想。并且还要多运用设计模式，运用设计模式要比理解还难，所以多运用，增强对设计模式的理解。</p><p>5.如何做到从了解模式到应用模式</p><p>答：首先应该正确理解设计模式，模式所关注的不仅是重复的解决方案，更主要的是关注重复出现的应用场景和与场景相关的各种作用力。其次应该针对问题，采取正确的设计模式，实际动手操作。应该做到看到一个问题能分析出需求的紧要程度，要在那个部分着重进行设计。还可以通过阅读成功的设计模式，来深入掌握设计模式的精髓，仔细分析成功的设计模式的设计思想，方便自己在之后中运用。</p><h2 id="四个要素"><a href="#四个要素" class="headerlink" title="四个要素"></a>四个要素</h2><p>设计模式使人们可以更加简单方便地复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。</p><h3 id="模式名称"><a href="#模式名称" class="headerlink" title="模式名称"></a>模式名称</h3><p>一个助记名，它用一两个词来描述模式的问题、解决方案和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>描述问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg" alt="image"></p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>总体来说设计模式分为三大类：</p><p>五种创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>七种结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>十一种行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><ul><li>工厂方法模式</li></ul><p>工厂方法模式的创建是因为简单工厂模式有一个问题，在简单工厂模式中类的创建依赖工厂类，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以就出现了工厂方法模式，只需要创建一个工厂接口和多个工厂实现类，子类可以自己决定实例化哪一个工厂类，client类针对抽象接口进行编程，如果需要增加新的功能，继承工厂接口，直接增加新的工厂类就可以了，创建过程延迟到子类中进行，不需要修改之前的代码，满足了开闭原则，达到灵活地生产多种对象。</p><ul><li>抽象工厂模式</li></ul><p>抽象工厂模式是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。区别于工厂方法模式的地方，工厂方法模式是创建一个工厂，可以实现多种对象；而抽象工厂模式是提供一个抽象工厂接口，里面定义多种工厂，每个工厂可以生产多种对象。前者的重点在于”怎么生产”，后者的重点在于”生产哪些”；前者是一个抽象产品类，可以派生出多个具体产品类，后者是多个抽象产品类，每个抽象产品类可以派生出多个具体产品类；前者的每个具体工厂类只能创建一个具体产品类的实例，后者的每个具体工厂类可以创建多个具体产品类的实例。</p><ul><li>单例模式</li></ul><p>单例模式能保证一个类仅有一个实例，并提供一个访问它的全局访问点，同时在类内部创造单一对象，通过设置权限，使类外部无法再创造对象。单例对象能保证在一个JVM中，该对象只有一个实例存在，这样做的好处就在于如果某些类创建比较频繁，特别是对于一些大型的对象，这是一笔很大的系统开销。在创建的时候，省去了new操作符，降低了系统内存的使用频率，减轻了系统的压力。同时单例模式保证在一个jvm中仅存在一个实例的好处就在于好比一个军队当中只会存在一个最高级别的军官来指挥整个军队，这样才能保证独立控制整个过程，否则如果出现多个，肯定会杂乱无序。</p><ul><li>建造者模式</li></ul><p>建造者模式是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示，就好比是每个饭店或者每家都会做西红柿炒鸡蛋，最后虽然都是西红柿炒鸡蛋的外观，但是由于当中的做饭过程存在差别，所以味道会不同。在程序当中就是将一些不会变的基本组件，通过builder来进行组合，构建复杂对象，实现分离。这样做的好处就在于客户端不必知道产品内部组成的细节；同时具体的建造者类之间是相互独立的，对系统的扩展非常有利，满足开闭原则；由于具体的建造者类是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p><ul><li>原型模式</li></ul><p>原型模式是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。其实就是将对象复制了一份并返还给调用者，对象需继承Cloneable并重写clone()方法。原型模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。分为浅复制和深复制，前者是将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的；后者是将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。</p><h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><ul><li>适配器模式</li></ul><p>适配器模式是使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，衔接两个不兼容、独立的接口的功能，使得它们能够一起工作，适配器起到中介的作用。</p><ul><li>装饰模式</li></ul><p>装饰器模式是动态地给一个对象添加一些额外的职责，给一个对象增加一些新的功能，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。除了动态的增加，也可以动态的撤销，要做到动态的形式，不可以用继承实现，因为继承是静态的。</p><ul><li>代理模式</li></ul><p>代理模式是为其他对象提供一种代理以控制对这个对象的访问，也就是创建类的代理类，间接访问被代理类的过程中，对其功能加以控制。它和装饰器模式的区别在于，装饰器模式为了增强功能，而代理模式是为了加以控制。代理模式就是多一个代理类出来，替原对象进行一些操作，例如买火车票不一定在火车站买，也可以去代售点。再比如打官司需要请律师，因为律师在法律方面有专长，可以替我们进行操作。</p><ul><li>外观模式</li></ul><p>外观模式是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。在客户端和复杂系统之间再加一层，提供一个容易使用的外观层。外观模式是为了解决类与类之家的依赖关系的，外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，比如搜狐门户网站，就利用了外观模式。</p><ul><li>桥接模式</li></ul><p>桥接模式是将抽象部分与实现部分分离，使它们都可以独立的变化。桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化（突然联想到了mvc模式）。将抽象化与实现化解耦，使得二者可以独立变化，就好比现在常说的mvc模式，view和model之间通过control来控制，达到高内聚低耦合来解耦的目的。</p><ul><li>组合模式</li></ul><p>组合模式是将对象组合成树形结构以表示”部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。创建了一个包含自己对象组的类，并提供修改对象组的方法。在系统的文件和文件夹的问题上就使用了组合模式，文件下不可以有对象，而文件夹下可以有文件对象或者文件夹对象。</p><ul><li>享元模式</li></ul><p>享元模式是运用共享技术有效地支持大量细粒度的对象。享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，重用现有的同类对象，若未找到匹配的对象，则创建新对象，这样可以减少对象的创建，降低系统内存，提高效率。</p><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><ul><li>策略模式</li></ul><p>策略模式是定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换，且算法的变化不会影响到使用算法的客户。。是为了统一接口下的一系列算法类（也就是多种策略），用一个类将其封装起来，使这些策略可动态切换。策略模式属于行为型模式，是为了使这些策略可以相互切换，是为了选择不同的行为。</p><ul><li>模版方法模式</li></ul><p>模板方法模式是定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。该模式就是在一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤，将一些固定步骤、固定逻辑的方法封装成模板方法。调用模板方法即可完成那些特定的步骤。</p><ul><li>观察者模式</li></ul><p>观察者模式是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。也就是当被观察者状态变化时，通知所有观察者，这种依赖方式具有双向性，在QQ邮箱中的邮件订阅和RSS订阅，当我们浏览一些博客时，经常会看到RSS图标，意思就是，当你订阅了该文章，如果后续有更新，会及时通知你。这种现象即是典型的观察者模式。</p><ul><li>迭代器模式</li></ul><p>迭代器模式是提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。在Java当中，将聚合类中遍历各个元素的行为分离出来，封装成迭代器，让迭代器来处理遍历的任务；使简化聚合类，同时又不暴露聚合类的内部，在我们经常使用的JDK中各个类也都是这些基本的东西。</p><ul><li>责任链模式</li></ul><p>责任链模式是避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求。在生活中学生进行请假的过程中，会涉及到，学生请假会一级一级往上批，最终处理，具体由谁批准可能不清楚。在程序当中，现在使用的struts拦截器即用到了责任链模式。</p><ul><li>命令模式</li></ul><p>命令模式是将一个请求封装成一个对象，从而使发出者可以用不同的请求对客户进行参数化。模式当中存在调用者、接收者、命令三个对象，实现请求和执行分开；调用者选择命令发布，命令指定接收者。举个例子，司令员下令让士兵去干件事情，司令员的作用是发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。司令士兵命令三者相互解耦，任何一方都不用去依赖其他人。其实struts框架也涉及到命令模式的思想。</p><ul><li>备忘录模式</li></ul><p>备忘录模式是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。创建一个备忘录类，用来存储原始类的信息；同时创建备忘录仓库类，用来存储备忘录类，主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，也就是做个备份。在系统当中使用的撤销操作，即是使用了备忘录模式，系统可以保存有限次数的文件状态，用户可以进行上几个状态的恢复，也就是用到了备忘录模式。</p><ul><li>状态模式</li></ul><p>状态模式是允许对象在内部状态发生改变时改变它的行为。对象具有多种状态，且每种状态具有特定的行为。在网站的积分系统中，用户具有不同的积分，也就对应了不同的状态；还有QQ的用户状态有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态。</p><ul><li>访问者模式</li></ul><p>访问者模式主要是将数据结构与数据操作分离。在被访问的类里面加一个对外提供接待访问者的接口，访问者封装了对被访问者结构的一些杂乱操作，解耦结构与算法，同时具有优秀的扩展性。通俗来讲就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。</p><ul><li>中介者模式</li></ul><p>中介者模式是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。例如，MVC模式中control就是model和view的中介者。与适配器区别在于，适配器是为了兼容不同的接口，而中介者是为了将显示和操作分离。</p><ul><li>解释器模式</li></ul><p>解释器模式是给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子，基本也就用在这个范围内，适用面较窄，例如：正则表达式的解释等。</p><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>1、开闭原则（Open Close Principle）</p><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p>2、里氏代换原则（Liskov Substitution Principle）</p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>3、依赖倒转原则（Dependence Inversion Principle）</p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p>4、接口隔离原则（Interface Segregation Principle）</p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p>5、迪米特法则，又称最少知道原则（Demeter Principle）</p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p>6、合成复用原则（Composite Reuse Principle）</p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 开发 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML解析过程</title>
      <link href="/2018/11/15/HTML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/11/15/HTML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.w3.org/TR/html5/images/parsing-model-overview.png" alt="image"></p><h2 id="浏览器渲染HTML过程"><a href="#浏览器渲染HTML过程" class="headerlink" title="浏览器渲染HTML过程"></a>浏览器渲染HTML过程</h2><blockquote><p>每个浏览器有自带的渲染引擎，用来渲染内容。浏览器可以渲染html、xml或者渲染其他内容。但此处只讨论html及css的渲染过程。目前主流的几款浏览器，Firefox、Chrome和Safari基于两种渲染方式。Chrome、Safari使用webkit引擎渲染内容，而Firefox使用Geoko渲染引擎。虽然webkit和Geoko是两种不同引擎，但是基本渲染过程并无太大差异，所以一起进行讨论。</p></blockquote><p>基本过程：</p><ol><li>解析html</li><li>加载外部样式及外部脚本</li><li>构建dom树</li><li>构建render树</li><li>布局render树</li><li>绘制render树</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 用户输入网址,浏览器会向该网址服务器发出请求,服务器会返回html文件;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 浏览器开始载入html代码,发现&lt;head&gt;标签内有一个&lt;link&gt;标签引用外部CSS文件;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 浏览器又发出CSS文件的请求,服务器返回这个CSS文件;同理也会返回链接的其他css,js文件等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 浏览器继续载入html中&lt;body&gt;部分的代码,并且CSS文件已经返回了,就可以开始渲染页面了;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 浏览器在代码中发现一个&lt;img&gt;标签引用了一张图片,向服务器发出请求。此时浏览器不会等到图片下载完,而是继续渲染后面的代码;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 服务器返回图片文件后,浏览器会回过头来重新渲染这部分代码;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. 如果浏览器在html文件底部发现了一段Javascript代码;Javascript脚本执行了这条语句,假设这段代码是隐藏前面的某一个&lt;div&gt;,浏览器不得不返回重新渲染这部分代码;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8. 最终加载到&lt;/html&gt;结尾标签,完成页面的加载;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9. 页面加载完后,如果又执行一些会导致页面变化的js,浏览器会返回重新渲染这段代码;</span><br></pre></td></tr></table></figure><h2 id="解析html、加载外部样式及外部脚本、构建dom树"><a href="#解析html、加载外部样式及外部脚本、构建dom树" class="headerlink" title="解析html、加载外部样式及外部脚本、构建dom树"></a>解析html、加载外部样式及外部脚本、构建dom树</h2><blockquote><p>浏览器有专门的html解析器来解析html，并在解析过程中构建dom树。浏览器是以自上而下的方式解析html，link、style、script等标签会使解析过程产生阻塞，等待外部资源加载才会继续解析。</p></blockquote><hr><p>外部样式会阻塞内部脚本的执行。</p><p>外部样式与外部脚本并行加载，但外部样式会阻塞外部脚本执行。</p><p>如果外部脚本带有async属性，则外部脚本的加载与执行不受外部样式影响</p><p>如果link标签是动态创建（js生成），不管有无async属性，都不会阻塞外部脚本的加载与执行。</p><hr><h2 id="构建render树"><a href="#构建render树" class="headerlink" title="构建render树"></a>构建render树</h2><blockquote><p>在外部样式加载执行后，将css附着到对应的dom节点上，开始构建render树。render树的每一个节点即为与其相对应的DOM节点的CSS框，框的类型与DOM节点的display属性有关，block元素生成block框，inline元素生成inline框。每一个render树节点都有与之相对应的DOM节点，但DOM节点不一定有与之相对应的render树节点，比如display属性为none的DOM节点，而且render树节点在render树中的位置与他们在DOM树中的位置不一定相同，比如float与绝对定位元素。</p></blockquote><hr><p>render树的节点与dom节点的display属性有关</p><p>display为none的dom节点没有对应的render节点</p><p>float属性、position属性可能改变dom节点在render树中的位置</p><p>javascript可以操作dom以及css样式改变render树的生成</p><hr><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/render.jpg" alt="image"></p><h2 id="布局render树、绘制render树"><a href="#布局render树、绘制render树" class="headerlink" title="布局render树、绘制render树"></a>布局render树、绘制render树</h2><p>render树构建完成后开始布局过程，浏览器会计算render树节点在屏幕中对应的位置。在布局完成后，浏览器将<br>render树绘制在屏幕的过程称为绘制。绘制完成后浏览器会呈现一张完整的网页。</p><blockquote><p>css样式会阻塞图片加载</p></blockquote><blockquote><p>脚本不会阻塞图片加载</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> 原理 </tag>
            
            <tag> 解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo的原理</title>
      <link href="/2018/11/14/hexo%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2018/11/14/hexo%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是用来生成 HTML 的，github pages 用来展示 HTML（根据上面的介绍，我们可以理解我们还可以使用 coding 的 pages 服务，如果自己有服务器的话，可以上传到自己的服务器）。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/12/1a5437eb122fc14fc88b1920aed5dcca?imageslim" alt="image"></p><p>在 Hexo 的官网，我们可以直观的看到对 Hexo 的介绍：快速、简洁且高效的博客框架</p><p>在 Hexo 的文档中，我们可以找到官方对 Hexo 的定义：</p><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><h2 id="Hexo-的工作原理"><a href="#Hexo-的工作原理" class="headerlink" title="Hexo 的工作原理"></a>Hexo 的工作原理</h2><p>这里我们来分析一下 Hexo 每次部署的流程</p><p>hexo g：生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p><p>hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p><h2 id="Hexo-的模板引擎"><a href="#Hexo-的模板引擎" class="headerlink" title="Hexo 的模板引擎"></a>Hexo 的模板引擎</h2><blockquote><p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p></blockquote><p>我们可以注意到，在 Hexo 中，source 文件夹和 themes 文件夹是在同级的，我们就可以将 source 文件夹理解为数据库，而主题文件夹相当于 界面。然后我们 hexo g 就将我们的数据和界面相结合生成静态文件 public。</p><p>Hexo 的模板引擎是默认使用 ejs 编写的。hexo首先会解析 md 文件，然后根据 layout 判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个 html 页面。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非要说 Hexo 是什么的话，我觉得就是生成静态页面的工具，可以将我们使用 markdown 编写的内容与主题模板相结合，生成 HTML 静态文件。并且可以和 github 的 pages 或者其他可以将静态页面展现出来的服务（例如 coding 的 pages 服务）相结合，一键部署。</p><p>再深入一点讲 Hexo 的原理的话，那就应该是使用 yaml 语言 做配置文件，使用 ejs 或者 swig 作为主题模板，与使用 markdown 书写的内容结合，生成静态 HTML 文件。</p><h2 id="hexo的常用命令"><a href="#hexo的常用命令" class="headerlink" title="hexo的常用命令"></a>hexo的常用命令</h2><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装</span><br><span class="line">npm update hexo -g #更新</span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt; #发表草稿。</span><br></pre></td></tr></table></figure><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;name&quot; #新建文章</span><br><span class="line">hexo g #生成静态网页</span><br><span class="line">hexo p #发表草稿。</span><br><span class="line">hexo s #启动服务</span><br><span class="line">hexo d #部署网站 参数：-g 部署之前先生成静态文件。</span><br></pre></td></tr></table></figure><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装才能使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save #安装服务</span><br><span class="line"></span><br><span class="line">hexo s #启动服务</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo s -s #静态模式</span><br><span class="line">hexo s -i 192.168.1.1 #自定义ip</span><br><span class="line"></span><br><span class="line">hexo clean #清除缓存</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>两者作用完全相同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>项目功能模块开发流程</title>
      <link href="/2018/11/13/%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/11/13/%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>首先在开始项目或者独立的功能模块之前，我们必须要清楚自己的目标、要做什么、要做成什么样的，拟定好目标之后就可以继续下一步</p><h2 id="技术文档"><a href="#技术文档" class="headerlink" title="技术文档"></a>技术文档</h2><p>当你开始着手一个项目或者模块开发时不要急着写代码，因为你不知道你该做什么，也不知道该怎么做。所以这时候技术文档就起到了一定的作用：帮你理清思路。</p><p>那么技术文档该怎么写呢？技术文档的格式是什么样的呢？</p><blockquote><p>技术文档内需要写的是你的思路、想法、技术相关的api。写文档的时候你可以将你的项目分层，分成不同层次，然后在开发的时候可以根据不同的层次进行开发。对于文档的格式的话，我本人认为也没有什么特定的格式，你只需要将你要做的事情从大到小的一一列举出来，只要能帮你理清思路、能够从头到尾的解释清你开发的东西是什么，那么这篇文档就是成功的。</p></blockquote><p>文档写完后又改干嘛呢？那肯定是将文字抽象出来，将其转化为我们大脑能够容易理解一点的东西：画图。</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>无论是做静态页面还是整个项目，画图也是必须的，图画能使我们大脑记的更深刻。我们也知道，图是我们的思维逻辑抽象出来的，我把图画好，那么逻辑应该是没有问题的</p><h3 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h3><p>xmind、思维脑图、时序图。。。其它的不一一列举</p><h3 id="图怎么画"><a href="#图怎么画" class="headerlink" title="图怎么画"></a>图怎么画</h3><p>画图是帮我们理清思维逻辑，比如写静态页面之前，我们画图需要画的就是从最外层画起、从大到小。那么做整个项目或者是功能模块该怎么画呢？其实不然，也是和画静态页面的图类似。</p><ul><li>先画相关页面的图</li><li>然后画交互图</li><li>最后通过xmind将其中所有详细步骤包括相关api<ul><li>分层开发，一般为界面交互，前端处理，后端处理</li><li>界面交互方法、事件</li><li>前端一般处理的是数据类型、数据流转等</li><li>后端只管接收数据、转发数据处理</li></ul></li></ul><p>画完图后那么该做什么呢？因为这只是项目功能模块开发流程，所以你可以开心对着自己的流程图进行开发了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js模拟UBB表情发送</title>
      <link href="/2018/11/10/ubb%E8%A1%A8%E6%83%85%E9%80%BB%E8%BE%91/"/>
      <url>/2018/11/10/ubb%E8%A1%A8%E6%83%85%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<p>最近本人在用react开发一个在线视频聊天的项目的时候碰到了一个难题：发送带有表情的消息，或许对于大部分人来说算不上什么，<br>但作为前端小白的我，挨过这个坎其实也不易。</p><p>无论做什么事情，思路不清逻辑不顺的话，不说百分之百，反正一般人独立解决问题的话应该会有些困难的，本人个人观点。废话不多说</p><p>以下就是我解决这个问题的主要逻辑和思路；</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://raw.githubusercontent.com/Foreverb/foreverb.github.io/master/images/step.jpg" alt="image"></p><h5 id="设置和获取光标位置，可以自己在网上查找相关功能接口"><a href="#设置和获取光标位置，可以自己在网上查找相关功能接口" class="headerlink" title="设置和获取光标位置，可以自己在网上查找相关功能接口"></a>设置和获取光标位置，可以自己在网上查找相关功能接口</h5><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>输入表情(微笑)或者(伤心) =&gt; [微笑] or [伤心]显示在输入框内，这就是下面会提到的UBB标签(字符串)；</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>前提，React Render 时，在JSX中，变量是 字符串或者是 JSX 对象，可以被正常渲染，字符串是字符串，JSX是对应的DOM元素</li><li>前提，React Render 时，在JSX中，变量是一个数组，数组中每个成员是字符串或者是JSX对象，则这个数组内所有的成员，都能被正常渲染</li><li>约定，发送或者接收的消息，都是特殊格式的字符串，聊天消息内容(字符串)+UBB标签(字符串)</li><li>猜想，若能够把消息字符串，转换为一个数组，聊天消息内容，为正常的字符串，UBB标签字符串转换为 JSX对象，类型为 img，img 的src 根据其内容不同而不同</li><li>故：只要把聊天消息，转换为React能接受的数组，即可完成 UBB表情功能</li></ol><p>由此，我做了一个实验，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如：你好[笑脸]，不要不理我，[哭脸]。</span><br><span class="line">生成：</span><br><span class="line">out = [</span><br><span class="line">  &quot;你好&quot;,</span><br><span class="line">  &lt;img src=&quot;1.jpg&quot;&gt;,</span><br><span class="line">  &quot;，不要不理我，&quot;</span><br><span class="line">  &lt;img src=&quot;2.jpg&quot;&gt;,</span><br><span class="line">  &quot;。&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我将这变量out以：{out}这种形式将其放在了jsx对象中，刷新页面，发现out中的内容被渲染成了<br>文字加图片的形式：”你好😁，不要不理我，😭 “。于是这个猜想得到了验证</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>两种方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//first</span><br><span class="line">var i;</span><br><span class="line">var arr;</span><br><span class="line">var re = /\[[\u4e00-\u9fa5]&#123;2&#125;\]/g;</span><br><span class="line">fn(str)&#123;</span><br><span class="line">    for(i=0;i&lt;str.length;i++)&#123;</span><br><span class="line">      if( str[i]!==&apos;[&apos; )&#123;</span><br><span class="line">        arr.push(str[i])</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        arr.push(str.slice(i,i+4));</span><br><span class="line">        i = i+4;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.map((item)=&gt;&#123;</span><br><span class="line">      if( re.test(item) )&#123;</span><br><span class="line">        return &lt;img src=&apos;&apos;/&gt;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">//second</span><br><span class="line">fn(str)&#123;</span><br><span class="line">  let word = str.split(re);</span><br><span class="line">  let src = str.match(re);</span><br><span class="line">  src = src.map((item)=&gt;&#123;</span><br><span class="line">    if( ChatClient.faceLibary[item] )&#123;</span><br><span class="line">      return &lt;img src=&#123;ChatClient.faceLibary[item]&#125;/&gt;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  let all = new Array(src.length+word.length).fill(0);</span><br><span class="line">  for (var i = 0; i &lt; all.length; i++) &#123;</span><br><span class="line">    for( var n = 0; n &lt; word.length; n++ )&#123;</span><br><span class="line">        all.splice(i,1,word[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    if( (i+2)%2 === 1 )&#123;</span><br><span class="line">      for(var j = 0; j &lt; src.length; j++)&#123;</span><br><span class="line">          all.splice(i,1,src[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也就是说，想要完成UBB表情功能，我们只需要将发送或者接受到的消息，从string的格式转化为<br>数组的格式，然后将这数组作为content，写入到jsx对象中，即可由react将其渲染为我们想看到<br>的内容：文字加图片</p><p>解决问题少不了逻辑和思维也就是思路，逻辑思维不清晰，最好不要继续下去，因为这样会使你大脑更乱<br>写代码亦是如此。</p><p>大胆猜想，小心实践，over ！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 工具 </tag>
            
            <tag> UBB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解 call，apply 和 bind</title>
      <link href="/2018/11/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3call,bind,apply%E5%8E%9F%E7%90%86/"/>
      <url>/2018/11/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3call,bind,apply%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="http://www.cnblogs.com/onepixel/p/5143863.html" target="_blank" rel="noopener">http://www.cnblogs.com/onepixel/p/5143863.html</a></p><p>在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到<code>移花接木</code>的效果。本文将对这三个方法进行详细的讲解，并列出几个经典应用场景。</p><h2 id="1、call-thisArgs-args…"><a href="#1、call-thisArgs-args…" class="headerlink" title="1、call(thisArgs [,args…])"></a>1、call(thisArgs [,args…])</h2><p>该方法可以传递一个thisArgs参数和一个参数列表，thisArgs 指定了函数在运行期的调用者，也就是函数中的 this 对象，而参数列表会被传入调用函数中。thisArgs 的取值有以下四种情况：</p><ul><li>不传，或者传null,undefined， 函数中的 this 指向 window 对象</li><li>传递另一个函数的函数名，函数中的 this 指向这个函数的引用</li><li>传递字符串、数值或布尔类型等基础类型，函数中的 this - 指向其对应的包装对象，如 String、Number、Boolean</li><li>传递一个对象，函数中的 this 指向这个对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    console.log(this);//输出函数a中的this对象</span><br><span class="line">&#125;</span><br><span class="line">function b()&#123;&#125;//定义函数b</span><br><span class="line"></span><br><span class="line">var obj = &#123;name:&apos;onepixel&apos;&#125;;//定义对象obj</span><br><span class="line"></span><br><span class="line">a.call();//window</span><br><span class="line">a.call(null);//window</span><br><span class="line">a.call(undefined);//window</span><br><span class="line">a.call(1);//Number</span><br><span class="line">a.call(&apos;&apos;);//String</span><br><span class="line">a.call(true);//Boolean</span><br><span class="line">a.call(b);// function b()&#123;&#125;</span><br><span class="line">a.call(obj);//Object</span><br></pre></td></tr></table></figure><p>这是call 的核心功能，它允许你在一个对象上调用该对象没有定义的方法，并且这个方法可以访问该对象中的属性，至于这样做有什么好处，我待会再讲，我们先看一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">    name:&apos;onepixel&apos;,//定义a的属性</span><br><span class="line"></span><br><span class="line">    say:function()&#123;//定义a的方法</span><br><span class="line">        console.log(&quot;Hi,I&apos;m function a!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function b(name)&#123;</span><br><span class="line">    console.log(&quot;Post params: &quot;+ name);</span><br><span class="line">    console.log(&quot;I&apos;m &quot;+this.name);</span><br><span class="line">    this.say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.call(a,&apos;test&apos;);</span><br><span class="line">&gt;&gt;</span><br><span class="line">Postparams: test</span><br><span class="line">I&apos;m onepixel</span><br><span class="line">I&apos;m function a!</span><br></pre></td></tr></table></figure><p>当执行b.call 时，字符串<code>test</code>作为参数传递给了函数b,由于call的作用，函数b中的this指向了对象a, 因此相当于调用了对象a上的函数b,而实际上a中没有定义b 。</p><h2 id="2、apply-thisArgs-args"><a href="#2、apply-thisArgs-args" class="headerlink" title="2、apply(thisArgs [,args[]])"></a>2、apply(thisArgs [,args[]])</h2><p>apply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。值得你注意的是，虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递，我们看个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function b(x,y,z)&#123;</span><br><span class="line">    console.log(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.apply(null,[1,2,3]);// 1 2 3</span><br></pre></td></tr></table></figure><p>apply 的这个特性很重要，我们会在下面的应用场景中提到这个特性。</p><h2 id="3、bind-thisArgs-args…"><a href="#3、bind-thisArgs-args…" class="headerlink" title="3、bind(thisArgs [,args…])"></a>3、bind(thisArgs [,args…])</h2><p>bind是ES5 新增的一个方法，它的传参和call类似，但又和 call/apply 有着显著的不同，即调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回了对函数的引用。粗略一看，bind 似乎比call/apply 要落后一些，那ES5为什么还要引入bind 呢？</p><p>其实，ES5引入 bind 的真正目的是为了弥补 call/apply 的不足，由于 call/apply 会对目标函数自动执行，从而导致它无法在事件绑定函数中使用，因为事件绑定函数不需要我们手动执行，它是在事件被触发时由JS 内部自动执行的。而 bind 在实现改变函数 this 的同时又不会自动执行目标函数，因此可以完美的解决上述问题，看一个例子就能明白：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&apos;onepixel&apos;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给document添加click事件监听，并绑定onClick函数</span><br><span class="line"> * 通过bind方法设置onClick的this为obj，并传递参数p1,p2</span><br><span class="line"> */</span><br><span class="line">document.addEventListener(&apos;click&apos;,onClick.bind(obj,&apos;p1&apos;,&apos;p2&apos;),false);</span><br><span class="line"></span><br><span class="line">//当点击网页时触发并执行</span><br><span class="line">function onClick(a,b)&#123;</span><br><span class="line">    console.log(</span><br><span class="line">            this.name,//onepixel</span><br><span class="line">            a,//p1</span><br><span class="line">            b //p2</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击网页时，onClick 被触发执行，输出onepixel p1 p2, 说明 onClick 中的 this 被 bind 改变成了obj 对象，为了对 bind 进行深入的理解，我们来看一下 bind 的 polyfill 实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if (!Function.prototype.bind) &#123;</span><br><span class="line">    Function.prototype.bind = function (oThis) &#123;</span><br><span class="line">        var aArgs = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">            fToBind =this,// this在这里指向的是目标函数</span><br><span class="line">            fBound = function () &#123;</span><br><span class="line">                return fToBind.apply(</span><br><span class="line">                    // 如果外部执行var obj = new fBound(),则将obj作为最终的this，放弃使用oThis</span><br><span class="line">                    this instanceof fToBind</span><br><span class="line">                            ?this  // 此时的this就是new出的obj</span><br><span class="line">                            : oThis ||this,// 如果传递的oThis无效，就将fBound的调用者作为this</span><br><span class="line"></span><br><span class="line">                    // 将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递</span><br><span class="line">                    aArgs.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        // 将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用</span><br><span class="line">        fBound.prototype =this.prototype;</span><br><span class="line"></span><br><span class="line">        // 返回fBond的引用，由外部按需调用</span><br><span class="line">        return fBound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。"><a href="#一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。" class="headerlink" title="一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。"></a>一旦函数通过bind传递了有效的this对象，则该函数在运行期的this将指向这个对象，即使通过call或apply来试图改变this的指向也是徒劳的。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 实现数组的去重功能</span><br><span class="line">Array.prototype.unique = function(fn) &#123;</span><br><span class="line">        var rst = [];</span><br><span class="line">        var tmp = &#123;&#125;;</span><br><span class="line">        this.forEach(function(val) &#123;</span><br><span class="line">            // 使用call来改变fn的this指向，这里传window</span><br><span class="line">            var key =&apos;uniq&apos; + (typeof fn ===&apos;function&apos; ? fn.call(window, val) : val);</span><br><span class="line">            if (!tmp.hasOwnProperty(key)) &#123;</span><br><span class="line">                rst.push(val);</span><br><span class="line">                tmp[key] =null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,this);</span><br><span class="line"></span><br><span class="line">        return rst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对象数组去重</span><br><span class="line">var arr = [</span><br><span class="line">    &#123; id: 2 &#125;, &#123; id: 4 &#125;, &#123; id: 3 &#125;, &#123; id: 3 &#125;, &#123; id: 4 &#125;, &#123; id: 6 &#125;</span><br><span class="line">]</span><br><span class="line">arr.unique(function(v) &#123;</span><br><span class="line">     console.log(this)// 使用bind传递了Array,则this一定是Array,而不会是window</span><br><span class="line">     return v.id</span><br><span class="line">&#125;.bind(Array));</span><br></pre></td></tr></table></figure><h2 id="4、应用场景一：继承"><a href="#4、应用场景一：继承" class="headerlink" title="4、应用场景一：继承"></a>4、应用场景一：继承</h2><p>大家知道，JavaScript中没有诸如Java、C# 等高级语言中的extend 关键字，因此JS 中没有继承的概念，如果一定要继承的话，call 和 apply 可以实现这个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name,weight)&#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat()&#123;</span><br><span class="line">    Animal.call(this,&apos;cat&apos;,&apos;50&apos;);</span><br><span class="line">  //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]);</span><br><span class="line"></span><br><span class="line">   this.say = function()&#123;</span><br><span class="line">      console.log(&quot;I am &quot; +this.name+&quot;,my weight is &quot; +this.weight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat =new Cat();</span><br><span class="line">cat.say();//I am cat,my weight is 50</span><br></pre></td></tr></table></figure><p>当通过new 运算符产生了cat 时，Cat中的 this 就指向了cat对象(关于new运算符的讲解，请参考JS构造函数和new运算符，而继承的关键是在于Cat中执行了Animal.call(this,’cat’,’50’) 这句话，在call中将this作为thisArgs参数传递，于是Animal 方法中的 this 就指向了Cat中的 this，而 cat 中的 this 指向的是 cat 对象，所以Animal 中的 this 指向的就是 cat 对象，在 Animal 中定义了name 和 weight 属性，就相当于在 cat 中定义了这些属性，因此 cat 对象便拥有了Animal 中定义的属性，从而达到了继承的目的。</p><h2 id="5、应用场景二：移花接木"><a href="#5、应用场景二：移花接木" class="headerlink" title="5、应用场景二：移花接木"></a>5、应用场景二：移花接木</h2><p>在讲下面的内容之前，我们首先来认识一下JavaScript 中的一个非标准专业术语：ArrayLike (类数组/伪数组)</p><p>ArrayLike 对象即拥有数组的一部分行为，在DOM 中早已表现出来，而jQuery 的崛起让ArrayLike 在JavaScript 中大放异彩。ArrayLike 对象的精妙在于它和JS 原生的 Array 类似，但是它是自由构建的，它来自开发者对JavaScript 对象的扩展，也就是说：对于它的原型(prototype)我们可以自由定义，而不会污染到JS原生的Array。</p><p>ArrayLike 对象在JS中被广泛使用，比如DOM 中的NodeList, 函数中的arguments 都是类数组对象，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法<code>移接</code>到ArrayLike 对象，从而达到操作其元素的目的。比如我们可以这样遍历函数中的arguments:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    // 检测arguments是否为Array的实例</span><br><span class="line">    console.log(</span><br><span class="line">            arguments instanceof Array,//false</span><br><span class="line">            Array.isArray(arguments) //false</span><br><span class="line">    );</span><br><span class="line">    // 判断arguments是否有forEach方法</span><br><span class="line">    console.log(arguments.forEach);//undefined</span><br><span class="line"></span><br><span class="line">    // 将数组中的forEach应用到arguments上</span><br><span class="line">    Array.prototype.forEach.call(arguments,function(item)&#123;</span><br><span class="line">        console.log(item);// 1 2 3 4</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">test(1,2,3,4);</span><br></pre></td></tr></table></figure><p>除此之外，对于apply 而言，我们上面提到了它独有的一个特性，即apply 接收的是数组，在传递给调用函数的时候是以参数列表传递的。 这个特性让apply 看起来比call 略胜一筹，比如有这样一个场景：给定一个数组[1,3,4,7]，然后求数组中的最大元素，而我们知道，数组中并没有获取最大值的方法，一般情况下，你需要通过编写代码来实现。而我们知道，Math 对象中有一个获取最大值的方法，即Math.max()， max方法需要传递一个参数列表，然后返回这些参数中的最大值。而apply 不仅可以将Math 对象的max 方法应用到其他对象上，还可以将一个数组转化为参数列表传递给max,看代码就能一目了然：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,1,5,4];</span><br><span class="line"></span><br><span class="line">Math.max.apply(null,arr);// 5</span><br></pre></td></tr></table></figure><p>以上便是 call 和 apply 比较经典的几个应用场景，熟练掌握这些技巧，并把这些特性应用到你的实际项目中，会使你的代码看起来更加耐人寻味！</p><hr><p>原创发布 @一像素  博客园 2016.01</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Node自动重启工具 nodemon</title>
      <link href="/2018/11/01/node%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/11/01/node%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要使用"><a href="#为什么要使用" class="headerlink" title="为什么要使用"></a>为什么要使用</h3><p>在编写调试Node.js项目，修改代码后，需要频繁的手动close掉，然后再重新启动，非常繁琐。现在，我们可以使用nodemon这个工具，它的作用是监听代码文件的变动，当代码改变之后，自动重启。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm/cnpm install -g nodemon</span><br></pre></td></tr></table></figure><p>安装在全局。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>编写代码 app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;)</span><br><span class="line"></span><br><span class="line">var app = express()</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;,function(req,res) &#123;</span><br><span class="line">    res.send(&quot;hello world&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000,function()&#123;</span><br><span class="line">    console.log(&apos;server is running&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里使用了express框架。</p><p>传统的方法，我们使用node app.js命令，程序将启动。其实，我们刚才下载的nodemon工具也可以用来启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure><p>我们访问3000端口，可以看到hellloworld。</p><p>我们现在尝试修改一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;,function(req,res) &#123;</span><br><span class="line">    res.send(&quot;hello 杨古波&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>保存之后，我们可以看到命令行中，输出了以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[nodemon] restarting due to changes...</span><br><span class="line">[nodemon] starting `node app.js`</span><br></pre></td></tr></table></figure><p>我们只需要刷新浏览器，就可以看到改动后的内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise 的基础用法</title>
      <link href="/2018/10/31/Promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2018/10/31/Promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise</p><p>所谓Promise ，简单说就是一个容器，里面保存着某个未来才回结束的事件(通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。<br>Promise 对象的状态不受外界影响</p><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态:"></a>三种状态:</h3><ul><li>pending：进行中</li><li>fulfilled :已经成功</li><li>rejected 已经失败</li></ul><p>状态改变：</p><p>Promise对象的状态改变，只有两种可能：</p><p>从pending变为fulfilled(resolve)</p><p>从pending变为rejected。(reject)</p><p>这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型）</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promist = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    if(/*异步操作成功*/)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p><p>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>Promise 实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value)&#123;</span><br><span class="line">//success</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">//failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        setTimeout(resolve,ms,&apos;done&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">timeout(100).then((value)=&gt;&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(&apos;Promise&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function()&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;Hi!&apos;);</span><br><span class="line"></span><br><span class="line">//Promise</span><br><span class="line">//Hi!</span><br><span class="line">//resolved</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//异步加载图片</span><br><span class="line">function loadImageAsync(url)&#123;</span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">        const image = new Image();</span><br><span class="line">        image.onload = function()&#123;</span><br><span class="line">            resolve(image);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = function()&#123;</span><br><span class="line">            reject(new Error(&apos;error&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.src = url;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个用Promise对象实现的 Ajax 操作的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">  const promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    const handler = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const client = new XMLHttpRequest();</span><br><span class="line">    client.open(&quot;GET&quot;, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = &quot;json&quot;;</span><br><span class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  console.log(&apos;Contents: &apos; + json);</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  console.error(&apos;出错了&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 语法 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git 常用命令</title>
      <link href="/2018/10/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/30/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的代码差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"># 从本地master拉取代码更新当前分支：branch 一般为master</span><br><span class="line">$ git rebase [branch]</span><br></pre></td></tr></table></figure><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update  --更新远程仓储</span><br><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git 创建、查看、删除、切换分支问题</title>
      <link href="/2018/10/29/git%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF/"/>
      <url>/2018/10/29/git%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%8C%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、使用背景"><a href="#一、使用背景" class="headerlink" title="一、使用背景"></a>一、使用背景</h2><p>总所周知，在日常开发中，我们需要把测试服务器和正式服务器分开。相应的，为了保持正式版本能正常运行，我们需要新建一个git分支用来专门的存放正式版APP的源码。</p><p>这样，每当我们生成一个版本的时候，我们都可以把稳定版本的源码放到online这个分支上。然后在master分支上继续开发新功能。当需要升级版本的时候，我们只需要把master分支上成熟的代码推送到online分支即可。</p><h2 id="二、创建分支及其相关命令"><a href="#二、创建分支及其相关命令" class="headerlink" title="二、创建分支及其相关命令"></a>二、创建分支及其相关命令</h2><p>1、创建新分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//新建online分支</span><br><span class="line">git checkout -b online</span><br></pre></td></tr></table></figure><p>2、查看当前所有分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//查看当前所有的分支</span><br><span class="line">git branch -a</span><br><span class="line">//结果显示带*号的，而且颜色是绿色的即为我们当前所在的分支</span><br><span class="line">*master</span><br><span class="line">online</span><br></pre></td></tr></table></figure><p>3、切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从当前的master分支切换到online分支上面</span><br><span class="line">git checkout online</span><br><span class="line">//此时可以查看分支,使用git branch即可看到master和online分支</span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><p>4、删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除online分支</span><br><span class="line">git branch -d online</span><br></pre></td></tr></table></figure><p>5、本地合并新分支代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//origin是本地默认的一个名称，自己在新建本地仓库的时候是可以改名的</span><br><span class="line">//平常使用的git pull都是默认从master分支上拉去代码。这里是从online分支上拉取代码</span><br><span class="line">git pull origin online</span><br></pre></td></tr></table></figure><p>6、本地提交代码到新的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里和上面的git pull差不多。是提交本地代码到online分支</span><br><span class="line">git push origin online</span><br></pre></td></tr></table></figure><h2 id="三、需要注意的问题"><a href="#三、需要注意的问题" class="headerlink" title="三、需要注意的问题"></a>三、需要注意的问题</h2><p>1、远程新建分支之后，本地如果立刻使用 git branch -a 查看分支的话，会看不到新建的分支。需要现在本地git pull一下。</p><p>2、如果我们已经通过git checkout master，切换到了master分支。那么我们在本地通过git pull和git push 都可以直接拉去或提交代码到master分支。git会默认使用你当前所在的分支</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js获取光标位置</title>
      <link href="/2018/10/16/js%E8%8E%B7%E5%8F%96%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/10/16/js%E8%8E%B7%E5%8F%96%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ol><li>概念和原理</li></ol><blockquote><p>DOM中并没有直接获取光标位置的方法，那么我们只能间接来获取光标位置。DOM支持获取光标选中的范围，我们可以以此为切入点，来获取或定位光标的位置。当选取范围起始点和结束点一样时，就是光标插入的位置。</p></blockquote><ul><li>术语</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">anchor(瞄点)：选区起点。</span><br><span class="line"></span><br><span class="line">focus(焦点)：选区终点。</span><br><span class="line"></span><br><span class="line">range(范围)：选区范围，包含整个节点或节点的一部分。</span><br></pre></td></tr></table></figure><ul><li>Selection</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Selection:Selection对象表示用户选择的文本范围或插入符号的位置。</span><br><span class="line"></span><br><span class="line">Selection对象存在于window对象上，可以通过window.getSelection()获取示例。</span><br></pre></td></tr></table></figure><h5 id="Selection选取的节点范围都是块级节点。input和texteare并不能作为Selection的节点"><a href="#Selection选取的节点范围都是块级节点。input和texteare并不能作为Selection的节点" class="headerlink" title="Selection选取的节点范围都是块级节点。input和texteare并不能作为Selection的节点"></a>Selection选取的节点范围都是块级节点。input和texteare并不能作为Selection的节点</h5><p>属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">anchorNode:选区起点的节点。</span><br><span class="line"></span><br><span class="line">anchorOffset:选区的起点位置。</span><br><span class="line"></span><br><span class="line">focusNode:选区终点的节点。</span><br><span class="line"></span><br><span class="line">focusOffset:选区的终点位置。</span><br><span class="line"></span><br><span class="line">isCollapsed:起点和终点是否重叠。</span><br><span class="line"></span><br><span class="line">rangeCount:选区包含的range数目。</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">getRangeAt(index):获取指定的选取范围。</span><br><span class="line"></span><br><span class="line">addRange(range):将一个范围添加到Selection对象中。</span><br><span class="line"></span><br><span class="line">removeRange():移出指定的范围。</span><br><span class="line"></span><br><span class="line">removeAllRanges():移出所有range对象。</span><br><span class="line"></span><br><span class="line">collapse(parentNode,offset):将光标移动到parentNode节点的offset位置。</span><br><span class="line"></span><br><span class="line">collapseToStart():取消当前选区，并把光标定位在原选区的最开始处，如果此时光标所处的位置是可编辑的，且它获得了焦点，则光标会在原地闪烁。</span><br><span class="line"></span><br><span class="line">collapseToEnd():取消当前选区，并将光标定位到原选取的最末位。如果此时光标所处的位置是可编辑的，且它获得了焦点，则光标会在原地闪烁。</span><br><span class="line"></span><br><span class="line">extend(node,offset):将终点位置移动到node节点的offset位置。</span><br><span class="line"></span><br><span class="line">modify(alter,direction,granularity):通过alter方式(move/extend)来改变光标位置，移动方向为direction(left/right)，移动单位为granularity。</span><br><span class="line"></span><br><span class="line">containsNode(aNode,aPartlyContained):判断aNode是否包含在Selection中。aPartlyContained为false表示全包含，为true表示只要部分包含即可。</span><br><span class="line"></span><br><span class="line">toString():放回当前Selection对象的字符串。</span><br></pre></td></tr></table></figure><ul><li>Range</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range对象表示一个Selection的选择范围，一个Selection可以包含多个Range。</span><br></pre></td></tr></table></figure><p>获取对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.createRange():创建一个Range。</span><br><span class="line"></span><br><span class="line">selection.getRangeAt(index):获取指定的Range。</span><br></pre></td></tr></table></figure><p>属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">collapsed:判断起始位置是否重合。</span><br><span class="line"></span><br><span class="line">endContaniner:range终点节点。</span><br><span class="line"></span><br><span class="line">endOffset:range的终点位置。</span><br><span class="line"></span><br><span class="line">startContaniner:ranstartge起点节点。</span><br><span class="line"></span><br><span class="line">startOffset:range的起点位置。</span><br><span class="line"></span><br><span class="line">commonAncestorContainer:包含起始点的节点。</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setStart(startNode,startOffset):设置范围在startNode的起始位置为startOffset。</span><br><span class="line"></span><br><span class="line">setEnd(endNode,endOffset):设置范围在endNode的起始位置为endOffset。</span><br><span class="line"></span><br><span class="line">selectNode(referenceNode):设置range的节点为referenceNode。</span><br><span class="line"></span><br><span class="line">selectNodeContents(referenceNode):设置range的内容为referenceNode。</span><br><span class="line"></span><br><span class="line">collapse(toStart):向边界点折叠range，即是设置光标位置，toStart默认为false，表示光标定位在节点末尾。true表示光标定位在节点起点。</span><br><span class="line"></span><br><span class="line">cloneContents():克隆一个range的内容片段。</span><br><span class="line"></span><br><span class="line">deleteContents():删除range的内容片段。</span><br><span class="line"></span><br><span class="line">extractContents():将range的内容从文档树移动到文档片段中。</span><br><span class="line"></span><br><span class="line">insertNode(newNode):在range的其实位置插入新的节点。</span><br><span class="line"></span><br><span class="line">surroundContents(newNode):将range对象的内容移动到新的节点中。</span><br><span class="line"></span><br><span class="line">cloneRange():克隆一个range对象。</span><br><span class="line"></span><br><span class="line">detach():释放当前range。</span><br></pre></td></tr></table></figure><ul><li>input/textarea</li></ul><blockquote><p>在html5中，可输入性表单元素（input/textarea）都存在以下属性。不支持IE6/7。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectionDirection:forward | backward | none,选区方向</span><br><span class="line">selectionEnd:选区终点位置</span><br><span class="line">selectionStart:选区起点位置</span><br></pre></td></tr></table></figure><blockquote><p>setSelectionRange(selectionStart, selectionEnd, [selectionDirection]):设置获取焦点的输入性元素的选区范围。</p></blockquote><ol start="2"><li>获取光标位置</li></ol><ul><li>可编辑div获取光标位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//获取当前光标位置</span><br><span class="line">const getCursortPosition = function (element) &#123;</span><br><span class="line">  var caretOffset = 0;</span><br><span class="line">  var doc = element.ownerDocument || element.document;</span><br><span class="line">  var win = doc.defaultView || doc.parentWindow;</span><br><span class="line">  var sel;</span><br><span class="line">  if (typeof win.getSelection != &quot;undefined&quot;) &#123;//谷歌、火狐</span><br><span class="line">    sel = win.getSelection();</span><br><span class="line">    if (sel.rangeCount &gt; 0) &#123;//选中的区域</span><br><span class="line">      var range = win.getSelection().getRangeAt(0);</span><br><span class="line">      var preCaretRange = range.cloneRange();//克隆一个选中区域</span><br><span class="line">      preCaretRange.selectNodeContents(element);//设置选中区域的节点内容为当前节点</span><br><span class="line">      preCaretRange.setEnd(range.endContainer, range.endOffset);  //重置选中区域的结束位置</span><br><span class="line">      caretOffset = preCaretRange.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if ((sel = doc.selection) &amp;&amp; sel.type != &quot;Control&quot;) &#123;//IE</span><br><span class="line">    var textRange = sel.createRange();</span><br><span class="line">    var preCaretTextRange = doc.body.createTextRange();</span><br><span class="line">    preCaretTextRange.moveToElementText(element);</span><br><span class="line">    preCaretTextRange.setEndPoint(&quot;EndToEnd&quot;, textRange);</span><br><span class="line">    caretOffset = preCaretTextRange.text.length;</span><br><span class="line">  &#125;</span><br><span class="line">  return caretOffset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取光标的位置是先通过获取鼠标的选取范围，然后克隆该选</span><br><span class="line">取范围，修改克隆范围的结束位置，这样克隆的范围就只剩下</span><br><span class="line">起点到结束点的内容，光标之后的内容被截取扔掉了。所以可</span><br><span class="line">以通过剩余内容的长度来确定光标位置。之所以要克隆一个选</span><br><span class="line">取范围出来，是为了避免修改光标结束位置时影响到原先内容</span><br></pre></td></tr></table></figure><p>input/textarea获取光标位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//输入框获取光标</span><br><span class="line">const getPosition = function (element) &#123;</span><br><span class="line">    let cursorPos = 0;</span><br><span class="line">    if (document.selection) &#123;//IE</span><br><span class="line">        var selectRange = document.selection.createRange();</span><br><span class="line">        selectRange.moveStart(&apos;character&apos;, -element.value.length);</span><br><span class="line">        cursorPos = selectRange.text.length;</span><br><span class="line">    &#125; else if (element.selectionStart || element.selectionStart == &apos;0&apos;) &#123;</span><br><span class="line">        cursorPos = element.selectionStart;</span><br><span class="line">    &#125;</span><br><span class="line">    return cursorPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>设置光标位置</li></ol><blockquote><p>可编辑div设置光标位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//设置光标位置</span><br><span class="line">const setCaretPosition = function (element, pos) &#123;</span><br><span class="line">  var range, selection;</span><br><span class="line">  if (document.createRange)//Firefox, Chrome, Opera, Safari, IE 9+</span><br><span class="line">  &#123;</span><br><span class="line">    range = document.createRange();//创建一个选中区域</span><br><span class="line">    range.selectNodeContents(element);//选中节点的内容</span><br><span class="line">    if(element.innerHTML.length &gt; 0) &#123;</span><br><span class="line">      range.setStart(element.childNodes[0], pos); //设置光标起始为指定位置</span><br><span class="line">    &#125;</span><br><span class="line">    range.collapse(true);       //设置选中区域为一个点</span><br><span class="line">    selection = window.getSelection();//获取当前选中区域</span><br><span class="line">    selection.removeAllRanges();//移出所有的选中范围</span><br><span class="line">    selection.addRange(range);//添加新建的范围</span><br><span class="line">  &#125;</span><br><span class="line">  else if (document.selection)//IE 8 and lower</span><br><span class="line">  &#123;</span><br><span class="line">    range = document.body.createTextRange();//Create a range (a range is a like the selection but invisible)</span><br><span class="line">    range.moveToElementText(element);//Select the entire contents of the element with the range</span><br><span class="line">    range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start</span><br><span class="line">    range.select();//Select the range (make it the visible selection</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> input/textarea获取光标位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 设置光标位置</span><br><span class="line">function setCaretPosition(textDom, pos)&#123;</span><br><span class="line">    if(textDom.setSelectionRange) &#123;</span><br><span class="line">        // IE Support</span><br><span class="line">        textDom.focus();</span><br><span class="line">        textDom.setSelectionRange(pos, pos);</span><br><span class="line">    &#125;else if (textDom.createTextRange) &#123;</span><br><span class="line">        // Firefox support</span><br><span class="line">        var range = textDom.createTextRange();</span><br><span class="line">        range.collapse(true);</span><br><span class="line">        range.moveEnd(&apos;character&apos;, pos);</span><br><span class="line">        range.moveStart(&apos;character&apos;, pos);</span><br><span class="line">        range.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>示例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;光标测试&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    p &#123;</span><br><span class="line">      display: flex;</span><br><span class="line">      flex-direction: row;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .btn &#123;</span><br><span class="line">      height: 24px;</span><br><span class="line">      margin: 0 10px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .edit-div &#123;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      width: 225px;</span><br><span class="line">      border: 1px solid #decdcd;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"></span><br><span class="line">    function getCursortPosition(e) &#123;</span><br><span class="line">      var eleP = e.target.parentNode; //获取父级元素</span><br><span class="line">      var pos = 0;</span><br><span class="line">      if (e.target.nodeName == &quot;DIV&quot;) &#123;</span><br><span class="line">        pos = getDivPosition(e.target);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        pos = getPosition(e.target);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var spanEle = (eleP.childNodes)[7];</span><br><span class="line">      spanEle.innerText = pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //可编辑div获取坐标</span><br><span class="line">    const getDivPosition = function (element) &#123;</span><br><span class="line">      var caretOffset = 0;</span><br><span class="line">      var doc = element.ownerDocument || element.document;</span><br><span class="line">      var win = doc.defaultView || doc.parentWindow;</span><br><span class="line">      var sel;</span><br><span class="line">      if (typeof win.getSelection != &quot;undefined&quot;) &#123;//谷歌、火狐</span><br><span class="line">        sel = win.getSelection();</span><br><span class="line">        if (sel.rangeCount &gt; 0) &#123;//选中的区域</span><br><span class="line">          var range = win.getSelection().getRangeAt(0);</span><br><span class="line">          var preCaretRange = range.cloneRange();//克隆一个选中区域</span><br><span class="line">          preCaretRange.selectNodeContents(element);//设置选中区域的节点内容为当前节点</span><br><span class="line">          preCaretRange.setEnd(range.endContainer, range.endOffset);  //重置选中区域的结束位置</span><br><span class="line">          caretOffset = preCaretRange.toString().length;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if ((sel = doc.selection) &amp;&amp; sel.type != &quot;Control&quot;) &#123;//IE</span><br><span class="line">        var textRange = sel.createRange();</span><br><span class="line">        var preCaretTextRange = doc.body.createTextRange();</span><br><span class="line">        preCaretTextRange.moveToElementText(element);</span><br><span class="line">        preCaretTextRange.setEndPoint(&quot;EndToEnd&quot;, textRange);</span><br><span class="line">        caretOffset = preCaretTextRange.text.length;</span><br><span class="line">      &#125;</span><br><span class="line">      return caretOffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //输入框获取光标</span><br><span class="line">    const getPosition = function (element) &#123;</span><br><span class="line">      let cursorPos = 0;</span><br><span class="line">      if (document.selection) &#123;//IE</span><br><span class="line">        var selectRange = document.selection.createRange();</span><br><span class="line">        selectRange.moveStart(&apos;character&apos;, -element.value.length);</span><br><span class="line">        cursorPos = selectRange.text.length;</span><br><span class="line">      &#125; else if (element.selectionStart || element.selectionStart == &apos;0&apos;) &#123;</span><br><span class="line">        cursorPos = element.selectionStart;</span><br><span class="line">      &#125;</span><br><span class="line">      return cursorPos;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;label&gt;输入框测试:&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; style=&quot;width:220px&quot; onclick=&quot;getCursortPosition(event);&quot; /&gt;</span><br><span class="line">    &lt;span&gt;光标位置:&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;label&gt;文本框测试:&lt;/label&gt;</span><br><span class="line">    &lt;textarea rows=&quot;5&quot; style=&quot;width:220px&quot; onclick=&quot;getCursortPosition(event);&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;span&gt;光标位置:&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label&gt;可编辑div:&lt;/label&gt;</span><br><span class="line">    &lt;div contenteditable=&quot;true&quot; class=&quot;edit-div&quot; onclick=&quot;getCursortPosition(event);&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;span&gt;光标位置:&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初级前端必学</title>
      <link href="/2018/07/20/%E5%88%9D%E7%BA%A7%E5%89%8D%E7%AB%AF%E5%BF%85%E7%9F%A5/"/>
      <url>/2018/07/20/%E5%88%9D%E7%BA%A7%E5%89%8D%E7%AB%AF%E5%BF%85%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><blockquote><p>学习HTML的基础知识</p></blockquote><blockquote><p>HTML语法</p></blockquote><blockquote><p>将页面划分多个部分并正确构建</p></blockquote><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><blockquote><p>学习css的基础知识</p></blockquote><blockquote><p>Grid布局和Flexbox布局</p></blockquote><blockquote><p>响应式web设计和媒体查询</p></blockquote><h1 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h1><blockquote><p>语法和基本的操作</p></blockquote><blockquote><p>DOM操作</p></blockquote><blockquote><p>变量提升、事件冒泡、原型</p></blockquote><blockquote><p>AJAX（XHR）</p></blockquote><blockquote><p>ECMA Script 6+，学习新的特性</p></blockquote><blockquote><p>JQuery（可选）</p></blockquote><h1 id="常用开发技能"><a href="#常用开发技能" class="headerlink" title="常用开发技能"></a>常用开发技能</h1><blockquote><p>GIT - 版本控制（GitHub，Bitbucket，GitLab）</p></blockquote><blockquote><p>HTTP/HTTPs协议—–请求方式：GET  POST   PUT   PATCH   DELETE   OPTIONS</p></blockquote><blockquote><p>学会寻找解决方案</p></blockquote><blockquote><p>终端的使用</p></blockquote><blockquote><p>数据结构和算法</p></blockquote><blockquote><p>设计模式</p></blockquote><h1 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h1><ol><li>包管理器</li></ol><blockquote><p>npm（一定掌握）</p></blockquote><blockquote><p>yarn（最好掌握）</p></blockquote><blockquote><p>pnpm（可以掌握）</p></blockquote><ol start="2"><li>任务运行器</li></ol><blockquote><p>npm脚本（一定掌握）</p></blockquote><blockquote><p>gulp（可以掌握）</p></blockquote><ol start="3"><li>WebPack（一定掌握）</li><li>Roolup（可以掌握）</li><li>Parcel（可以掌握）</li></ol><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><ul><li>CSS预处理器</li></ul><blockquote><p>Sass/Css（一定掌握）</p></blockquote><blockquote><p>PostCSS（一定掌握）</p></blockquote><blockquote><p>Less（可以掌握）</p></blockquote><blockquote><p>Stylus（可以掌握）</p></blockquote><ul><li>CSS框架</li></ul><blockquote><p>BootStrap（最好掌握）</p></blockquote><blockquote><p>Materialize、Material UI、Material Design Lite（最好掌握）</p></blockquote><blockquote><p>Bulma（可以掌握）</p></blockquote><blockquote><p>Semantic UI（可以掌握）</p></blockquote><ul><li>CSS架构</li></ul><blockquote><p>BEM（一定掌握）</p></blockquote><blockquote><p>CSS Modules（最好掌握）</p></blockquote><blockquote><p>Atomic（可以掌握）</p></blockquote><blockquote><p>OOCSS（可以掌握）</p></blockquote><blockquote><p>SMACSS（可以掌握）</p></blockquote><blockquote><p>SUITCSS（可以掌握）</p></blockquote><ul><li>JS编写CSS</li></ul><blockquote><p>Styled Components（最好掌握）</p></blockquote><blockquote><p>Radium（最好掌握）</p></blockquote><blockquote><p>Emotion（最好掌握）</p></blockquote><blockquote><p>JSS（可以掌握）</p></blockquote><blockquote><p>Aphrodite（可以掌握）</p></blockquote><h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><ul><li>Mobx（最好掌握）</li><li>组件状态/上下文API（一定掌握）</li><li>Redux（一定掌握）</li></ul><ol><li>异步操作（side  Effects）</li></ol><blockquote><p>Redux Thunk（最好掌握）</p></blockquote><blockquote><p>Redux Better Promise（最好掌握）</p></blockquote><blockquote><p>Redux Sage（最好掌握）</p></blockquote><blockquote><p>Redux Observable（最好掌握）</p></blockquote><ol start="2"><li>数据持久化</li></ol><blockquote><p>Redux Persist（可以掌握）</p></blockquote><blockquote><p>Redux Phoenix（可以掌握）</p></blockquote><ol start="3"><li>Redux  Form（最好掌握）</li></ol><h1 id="类型检查器"><a href="#类型检查器" class="headerlink" title="类型检查器"></a>类型检查器</h1><blockquote><p>PropTypes（一定掌握）</p></blockquote><blockquote><p>TypeScript（最好掌握）</p></blockquote><blockquote><p>Flow（最好掌握）</p></blockquote><h1 id="表单助手"><a href="#表单助手" class="headerlink" title="表单助手"></a>表单助手</h1><blockquote><p>Redux Form（最好掌握）</p></blockquote><blockquote><p>Formik（最好掌握）</p></blockquote><blockquote><p>Formsy（可以掌握）</p></blockquote><blockquote><p>Final Form（可以掌握）</p></blockquote><h1 id="API客户端"><a href="#API客户端" class="headerlink" title="API客户端"></a>API客户端</h1><ul><li>REST</li></ul><blockquote><p>Fetch（一定掌握）</p></blockquote><blockquote><p>SuperAgent（最好掌握）</p></blockquote><blockquote><p>axios（最好掌握）</p></blockquote><ul><li>GraphQL</li></ul><blockquote><p>Apollo（最好掌握）</p></blockquote><blockquote><p>Relay（可以掌握）</p></blockquote><blockquote><p>urpl（可以掌握）</p></blockquote><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><blockquote><p>React-Router（一定掌握）</p></blockquote><blockquote><p>Routers（可以掌握）</p></blockquote><blockquote><p>Redux-First Router（可以掌握）</p></blockquote><blockquote><p>Reach Router（可以掌握）</p></blockquote><h1 id="使用工具库"><a href="#使用工具库" class="headerlink" title="使用工具库"></a>使用工具库</h1><blockquote><p>Lodash（一定掌握）</p></blockquote><blockquote><p>Moment（一定掌握）</p></blockquote><blockquote><p>classnames（一定掌握）</p></blockquote><blockquote><p>Numeral（最好掌握）</p></blockquote><blockquote><p>RxJS（最好掌握）</p></blockquote><blockquote><p>Ramda（可以掌握）</p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>单元测试</li></ol><blockquote><p>Jest（一定掌握）</p></blockquote><blockquote><p>Enzyme（一定掌握）</p></blockquote><blockquote><p>Sinon（一定掌握）</p></blockquote><blockquote><p>Mocha（最好掌握）</p></blockquote><blockquote><p>Chai（最好掌握）</p></blockquote><blockquote><p>AVA（可以掌握）</p></blockquote><blockquote><p>Tape（可以掌握）</p></blockquote><ol start="2"><li>端到端测试</li></ol><blockquote><p>Selenlum（最好掌握）</p></blockquote><blockquote><p>Cypress（最好掌握）</p></blockquote><blockquote><p>Puppeteer（最好掌握）</p></blockquote><blockquote><p>Cucumber.js（最好掌握）</p></blockquote><ol start="3"><li>集成测试</li></ol><blockquote><p>Karma（最好掌握）</p></blockquote><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><blockquote><p>React Int（一定掌握）</p></blockquote><blockquote><p>React i 18 next（最好掌握）</p></blockquote><h1 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h1><blockquote><p>next.JS（最好掌握）</p></blockquote><blockquote><p>After.JS（可以掌握）</p></blockquote><h1 id="静态网站生成器"><a href="#静态网站生成器" class="headerlink" title="静态网站生成器"></a>静态网站生成器</h1><blockquote><p>Gatsby（最好掌握）</p></blockquote><h1 id="后端集成框架"><a href="#后端集成框架" class="headerlink" title="后端集成框架"></a>后端集成框架</h1><blockquote><p>React on Rails（可以掌握）</p></blockquote><h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><blockquote><p>React Native（可以掌握）</p></blockquote><blockquote><p>Cordova / Phonegap（可以掌握）</p></blockquote><h1 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h1><blockquote><p>Proton Native（可以掌握）</p></blockquote><blockquote><p>Electron（可以掌握）</p></blockquote><blockquote><p>React Native Windows（可以掌握）</p></blockquote><h1 id="虚拟现实-VR"><a href="#虚拟现实-VR" class="headerlink" title="虚拟现实(VR)"></a>虚拟现实(VR)</h1><blockquote><p>React 360（可以掌握）</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ALL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>箭头函数</title>
      <link href="/2018/07/06/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/06/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="箭头函数没有arugments"><a href="#箭头函数没有arugments" class="headerlink" title="箭头函数没有arugments"></a>箭头函数没有arugments</h2><p>普通函数有arguments</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123; console.log(arguments) &#125;</span><br><span class="line">a(1,2,3)</span><br><span class="line"></span><br><span class="line">// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></table></figure><p>箭头函数才有 arguments</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = ()=&gt;&#123; console.log(arguments) &#125;</span><br><span class="line">b(1,2,3)</span><br><span class="line">// VM13852:1 Uncaught ReferenceError: arguments is not defined</span><br></pre></td></tr></table></figure><h2 id="箭头函数的this为定义时的环境"><a href="#箭头函数的this为定义时的环境" class="headerlink" title="箭头函数的this为定义时的环境"></a>箭头函数的this为定义时的环境</h2><p>函数定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br></pre></td></tr></table></figure><p>真实函数定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>( <span class="built_in">window</span> )&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头函数原理</span></span><br><span class="line">    <span class="keyword">var</span> c = <span class="function">(<span class="params"> (v</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;.bind( v )</span><br><span class="line"></span><br><span class="line">    &#125; )( <span class="keyword">this</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a;</span><br><span class="line"><span class="comment">// ƒ a()&#123; console.log(this) &#125;</span></span><br><span class="line">b;</span><br><span class="line"><span class="comment">// ()=&gt;&#123; console.log(this) &#125;</span></span><br></pre></td></tr></table></figure><p>执行返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a()</span><br><span class="line"><span class="comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br><span class="line"></span><br><span class="line">b()</span><br><span class="line"><span class="comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br></pre></td></tr></table></figure><p>其他对象调用返回<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;&#125;</span><br><span class="line">obj.name = <span class="string">'myObj'</span>;</span><br><span class="line">obj.fa = a;</span><br><span class="line">obj.fb = b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj.fa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;fa: ƒ, name: "myObj", fb: ƒ&#125;</span></span><br><span class="line">obj.fb();</span><br><span class="line"><span class="comment">// Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>硬连接和软连接</title>
      <link href="/2018/07/06/20180706-%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/07/06/20180706-%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h1><ol><li>inode（即索引节点号）是Linux系统识别文件的唯一标识。</li><li>系统是通过inode来查找正确的文件数据块，并不是通过文件名。</li></ol><h4 id="Linux系统中文件数据分为两类：metadata（元数据）和data（普通数据）。"><a href="#Linux系统中文件数据分为两类：metadata（元数据）和data（普通数据）。" class="headerlink" title="Linux系统中文件数据分为两类：metadata（元数据）和data（普通数据）。"></a>Linux系统中文件数据分为两类：metadata（元数据）和data（普通数据）。</h4><p>元数据存放的是文件的附加属性，例如大小、时间戳、所有者等。普通数据才是真正的数据内容。</p><h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><p>在Linux系统为了解决文件共享问题，使用两种方式：hard link（硬链接）和soft link（软链接），链接不仅仅可以共享文件，还有方便管理、隐藏路径、节省空间等好处。</p><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><h3 id="若是使用同一个inode对应多个文件，则使用的就是硬链接。"><a href="#若是使用同一个inode对应多个文件，则使用的就是硬链接。" class="headerlink" title="若是使用同一个inode对应多个文件，则使用的就是硬链接。"></a>若是使用同一个inode对应多个文件，则使用的就是硬链接。</h3><p>硬链接可以使用link和ln创建</p><p>语法：ln filename [linkname ]</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">link data link</span><br><span class="line">ln data link</span><br></pre></td></tr></table></figure><ol><li>只能和已存在的文件建立硬链接</li></ol><h4 id="我们在-app目录下进行实验，当硬链接的源文件不存在时，硬链接无法创建"><a href="#我们在-app目录下进行实验，当硬链接的源文件不存在时，硬链接无法创建" class="headerlink" title="我们在/app目录下进行实验，当硬链接的源文件不存在时，硬链接无法创建"></a>我们在/app目录下进行实验，当硬链接的源文件不存在时，硬链接无法创建</h4><ol start="2"><li>文件的inode相同和文件属性，只是文件名不同</li></ol><h4 id="我们在-app目录下创建一个data的源文件，并通过stat-命令查看文件属性，然后创建硬链接link，ll-i-查看两者的inode相同，从ctime的变化也能确定硬链接就是用一个文件"><a href="#我们在-app目录下创建一个data的源文件，并通过stat-命令查看文件属性，然后创建硬链接link，ll-i-查看两者的inode相同，从ctime的变化也能确定硬链接就是用一个文件" class="headerlink" title="我们在/app目录下创建一个data的源文件，并通过stat 命令查看文件属性，然后创建硬链接link，ll -i 查看两者的inode相同，从ctime的变化也能确定硬链接就是用一个文件"></a>我们在/app目录下创建一个data的源文件，并通过stat 命令查看文件属性，然后创建硬链接link，ll -i 查看两者的inode相同，从ctime的变化也能确定硬链接就是用一个文件</h4><ol start="3"><li>不能跨文件系统建立硬链接</li></ol><h4 id="在-dev目录下建立硬链接link，因为所在不同的文件系统，所以不能建立硬链接"><a href="#在-dev目录下建立硬链接link，因为所在不同的文件系统，所以不能建立硬链接" class="headerlink" title="在/dev目录下建立硬链接link，因为所在不同的文件系统，所以不能建立硬链接"></a>在/dev目录下建立硬链接link，因为所在不同的文件系统，所以不能建立硬链接</h4><ol start="4"><li>硬链接创建后链接数会增加</li></ol><h4 id="我们通过对link和data建立新的硬链接link2和link3，发现链数都有增长，由此也能看出硬链接实质上就是同一个文件"><a href="#我们通过对link和data建立新的硬链接link2和link3，发现链数都有增长，由此也能看出硬链接实质上就是同一个文件" class="headerlink" title="我们通过对link和data建立新的硬链接link2和link3，发现链数都有增长，由此也能看出硬链接实质上就是同一个文件"></a>我们通过对link和data建立新的硬链接link2和link3，发现链数都有增长，由此也能看出硬链接实质上就是同一个文件</h4><ol start="5"><li>不能对目录创建硬链接</li></ol><h4 id="在-app目录下创建dir1目录文件，尝试建立硬链接link4，创建失败。因为硬链接能针对目录创建"><a href="#在-app目录下创建dir1目录文件，尝试建立硬链接link4，创建失败。因为硬链接能针对目录创建" class="headerlink" title="在/app目录下创建dir1目录文件，尝试建立硬链接link4，创建失败。因为硬链接能针对目录创建"></a>在/app目录下创建dir1目录文件，尝试建立硬链接link4，创建失败。因为硬链接能针对目录创建</h4><ol start="6"><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件数据</li></ol><h4 id="在删除源文件data的之前，查看源文件和链接文件的数据是一致的。在删除data之后，其他的硬链接文件的内容不受影响，只是链接数减少了"><a href="#在删除源文件data的之前，查看源文件和链接文件的数据是一致的。在删除data之后，其他的硬链接文件的内容不受影响，只是链接数减少了" class="headerlink" title="在删除源文件data的之前，查看源文件和链接文件的数据是一致的。在删除data之后，其他的硬链接文件的内容不受影响，只是链接数减少了"></a>在删除源文件data的之前，查看源文件和链接文件的数据是一致的。在删除data之后，其他的硬链接文件的内容不受影响，只是链接数减少了</h4><h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><h2 id="软链接的特性"><a href="#软链接的特性" class="headerlink" title="软链接的特性"></a>软链接的特性</h2><ol><li><p>软链接其实存放的就是源文件的路径，所以如果文件的内容数据是另一个文件的路径时，这个文件就是软链接。</p></li><li><p>软链接有自己独立的inode和文件属性，这点和硬链接有本质的区别</p></li></ol><p>语法：ln -s filename [linkname ]</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">link -s data link</span><br><span class="line">ln -s data link</span><br></pre></td></tr></table></figure><ol><li>软链接可对不存在文件建立链接</li></ol><h4 id="在-app的空目录中，建立软链接，目录下没有文件，但链接依旧能建立，找不到目标文件会有报错提示"><a href="#在-app的空目录中，建立软链接，目录下没有文件，但链接依旧能建立，找不到目标文件会有报错提示" class="headerlink" title="在/app的空目录中，建立软链接，目录下没有文件，但链接依旧能建立，找不到目标文件会有报错提示"></a>在/app的空目录中，建立软链接，目录下没有文件，但链接依旧能建立，找不到目标文件会有报错提示</h4><ol start="2"><li>软链接有自己的inode和属性</li></ol><h4 id="在目录下建立文件soft，之后对soft设置软链接slink，通过stat-命令查看soft和slink的文件属性，可以看出和之前硬链接的本质区别，不论是权限、inode、时间戳、大小、数据块都不同"><a href="#在目录下建立文件soft，之后对soft设置软链接slink，通过stat-命令查看soft和slink的文件属性，可以看出和之前硬链接的本质区别，不论是权限、inode、时间戳、大小、数据块都不同" class="headerlink" title="在目录下建立文件soft，之后对soft设置软链接slink，通过stat 命令查看soft和slink的文件属性，可以看出和之前硬链接的本质区别，不论是权限、inode、时间戳、大小、数据块都不同"></a>在目录下建立文件soft，之后对soft设置软链接slink，通过stat 命令查看soft和slink的文件属性，可以看出和之前硬链接的本质区别，不论是权限、inode、时间戳、大小、数据块都不同</h4><ol start="3"><li>软链接可跨文件系统建立</li></ol><h4 id="在-dev目录下建立test文件目录用于实验，然后设置软链接testlink"><a href="#在-dev目录下建立test文件目录用于实验，然后设置软链接testlink" class="headerlink" title="在/dev目录下建立test文件目录用于实验，然后设置软链接testlink"></a>在/dev目录下建立test文件目录用于实验，然后设置软链接testlink</h4><ol start="4"><li>软链接可以对目录文件建立</li></ol><h4 id="接着直接以-app-testdir为目标文件，和-dev-test目录文件，建立软链接"><a href="#接着直接以-app-testdir为目标文件，和-dev-test目录文件，建立软链接" class="headerlink" title="接着直接以/app/testdir为目标文件，和/dev/test目录文件，建立软链接"></a>接着直接以/app/testdir为目标文件，和/dev/test目录文件，建立软链接</h4><ol start="5"><li>软链接创建不会增加链接数</li></ol><h4 id="建立了软链接，而链接数还是1没有改变"><a href="#建立了软链接，而链接数还是1没有改变" class="headerlink" title="建立了软链接，而链接数还是1没有改变"></a>建立了软链接，而链接数还是1没有改变</h4><ol start="6"><li>删除软链接并不影响源文件，但删除源文件软链接就会变成死链接，若链接指向的路径文件被重新建立，则链接恢复</li></ol><h4 id="在-app目录下再创创建一个软链接slink2，在我们删除slink之后，源文件soft和slink2都没有受到影响，但当我们把soft文件删除后，slink2就变成了死链接，不再能显示数据"><a href="#在-app目录下再创创建一个软链接slink2，在我们删除slink之后，源文件soft和slink2都没有受到影响，但当我们把soft文件删除后，slink2就变成了死链接，不再能显示数据" class="headerlink" title="在/app目录下再创创建一个软链接slink2，在我们删除slink之后，源文件soft和slink2都没有受到影响，但当我们把soft文件删除后，slink2就变成了死链接，不再能显示数据"></a>在/app目录下再创创建一个软链接slink2，在我们删除slink之后，源文件soft和slink2都没有受到影响，但当我们把soft文件删除后，slink2就变成了死链接，不再能显示数据</h4><h2 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h2><p>使用find 命令可以查找链接文件</p><ol><li>查找目录文件下相同inode的文件</li></ol><h4 id="find-dirs-inum-inode"><a href="#find-dirs-inum-inode" class="headerlink" title="find /dirs inum inode"></a>find /dirs inum inode</h4><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>硬链接本质上就是同一个文件的不同文件名。软链接就是独立的文件，不过文件中存放的是源文件的路径。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端求职面试问题</title>
      <link href="/2018/07/05/20180705-%E5%BC%80%E6%BA%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/07/05/20180705-%E5%BC%80%E6%BA%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>( 前端求职面试问题 )</p><h1 id="Front-end-Job-Interview-Questions"><a href="#Front-end-Job-Interview-Questions" class="headerlink" title="Front-end Job Interview Questions"></a>Front-end Job Interview Questions</h1><h2 id="Table-of-Contents-目录表"><a href="#Table-of-Contents-目录表" class="headerlink" title="Table of Contents( 目录表 )"></a>Table of Contents( 目录表 )</h2><ol><li>General Questions   （ 一般的问题 ）</li><li>HTML Questions       ( HTML问题 )</li><li>CSS Questions        ( CSS问题 )</li><li>JS Questions         ( JS问题 )</li><li>Network Questions    ( 网络问题 )</li><li>Coding Questions     ( 代码问题 )</li><li>Fun Questions        ( 有趣的问题 )</li></ol><hr><h3 id="General-Questions"><a href="#General-Questions" class="headerlink" title="General Questions"></a>General Questions</h3><ul><li>What did you learn yesterday/this week?<blockquote><p>昨天或者说这个星期你学到了什么？</p></blockquote></li><li>What excites or interests you about coding?<blockquote><p>你对代码感兴趣吗？</p></blockquote></li><li>What is a recent technical challenge you experienced and how did you solve it?<blockquote><p>你最近遇到的技术挑战是什么?你是如何解决的？</p></blockquote></li><li>What UI, Security, Performance, SEO, Maintainability or Technology considerations do you make while building a web application or site?<blockquote><p>在构建web应用程序或站点时，你会做哪些UI，安全性，性能，SEO，可维护性或技术方面的考虑</p></blockquote></li><li>Talk about your preferred development environment.<blockquote><p>谈谈你喜欢的开发环境</p></blockquote></li><li>Which version control systems are you familiar with?<blockquote><p>你熟悉哪些版本控制系统  </p></blockquote></li><li>Can you describe your workflow when you create a web page?<blockquote><p>当你创建网页时，能描述你的工作流程吗？</p></blockquote></li><li>If you have 5 different stylesheets, how would you best integrate them into the site?<blockquote><p>如果你有5个不同的样式表，你如何将它们最好的集成到站点中？</p></blockquote></li><li>Can you describe the difference between progressive enhancement and graceful degradation?<blockquote><p>你能描述渐进增强和优雅退化的区别吗？</p></blockquote></li><li>How would you optimize a website’s assets/resources?<blockquote><p>如何优化你的站点资源</p></blockquote></li><li>How many resources will a browser download from a given domain at a time?<blockquote><p>一次有多少资源将会被从一个给定的域下载</p></blockquote></li><li>What are the exceptions?<blockquote><p>将会有什么异常</p></blockquote></li><li>Name 3 ways to decrease page load (perceived or actual load time).<blockquote><p>列出3种减少页面</p></blockquote></li><li>If you jumped on a project and they used tabs and you used spaces, what would you do?<blockquote><p> 如果你临时加入一个项目，他们用Tabs你使用spaces，你会怎么做</p></blockquote></li><li>Describe how you would create a simple slideshow page.<blockquote><p> 描述如何创建一个简单的幻灯片页面？</p></blockquote></li><li>If you could master one technology this year, what would it be?<blockquote><p> 如果今年你能掌握一项技术，会是什么？</p></blockquote></li><li>Explain the importance of standards and standards bodies.<blockquote><p> 解释标准和标准机构的重要性  </p></blockquote></li><li>What is Flash of Unstyled Content? How do you avoid FOUC?<blockquote><p> 什么是无格式内容的Flash？如何避免犯规？</p></blockquote></li><li><p>Explain what ARIA（Accessible Rich Internet Applications ） and screenreaders are, and how to make a website accessible.</p><blockquote><p>解释下什么是ARIA和screenreaders，并且如何建立一个可用性站点</p></blockquote></li><li><p>Explain some of the pros and cons for CSS animations versus JavaScript animations.</p><blockquote><p> 解释CSS动画和Javascript动画的利弊？</p></blockquote></li></ul><hr><h3 id="HTML-Questions"><a href="#HTML-Questions" class="headerlink" title="HTML Questions:"></a>HTML Questions:</h3><ul><li>What does a doctype do?<blockquote><p>DOCTYPE是做什么的？</p></blockquote></li><li>What’s the difference between standards mode and quirks mode?<blockquote><p> 标准和模型和怪癖盒模型有什么不同  </p></blockquote></li><li>What’s the difference between HTML and XHTML?<blockquote><p>HTML和XHTML之间的不同</p></blockquote></li><li>Are there any problems with serving pages as application/xhtml+xml?<blockquote><p> 服务页面作为应用程序，XHTML+XML有什么问题</p></blockquote></li><li>How do you serve a page with content in multiple languages?<blockquote><p> 如何使用多语言的内容服务页面</p></blockquote></li><li>What kind of things must you be wary of when design or developing for multilingual sites?<blockquote><p> 当设计或开发多语言网站时，你必须谨防什么样的事情？</p></blockquote></li><li>What are data- attributes good for?<blockquote><p> 数据类型有什么用？</p></blockquote></li><li>Consider HTML5 as an open web platform. What are the building blocks of HTML5?<blockquote><p> 将HTML5视为一个开放的web平台，HTML5的组成部分是什么？</p></blockquote></li><li>Describe the difference between a cookie, sessionStorage and localStorage.<blockquote><p> 描述一下cookie，sessionStorage和localStorage之间的区别</p></blockquote></li><li>Describe the difference between <script>, <script async> and <script defer>.<blockquote><p> 描述一下<script>,<script async>和<script defer>之间的不同？</p></blockquote></li><li>Why is it generally a good idea to position CSS <link>s between <head></head> and JS <script>s just before </body>? Do you know any exceptions?<blockquote><p> 为什么css的<link>标签要在head标签内，JS的<script>标签在<body>标签之前，你知道什么情况下例外？</p></blockquote></li><li>What is progressive rendering?<blockquote><p> 什么是渐进式渲染？</p></blockquote></li><li>Have you used different HTML templating languages before?<blockquote><p> 你之前使用过不同的HTML的模板语言吗？</p></blockquote></li></ul><hr><h3 id="CSS-Questions"><a href="#CSS-Questions" class="headerlink" title="CSS Questions:"></a>CSS Questions:</h3><ul><li>What is the difference between classes and ID’s in CSS?</li><li>id选择器与class选择器的不同</li><li>What’s the difference between “resetting” and “normalizing” CSS? Which would you choose, and why?<blockquote><p> 重置和标准化css有什么区别？你会选哪一个？为什么？</p></blockquote></li><li>Describe Floats and how they work.<blockquote><p> 描述浮动一级它是如何工作的？</p></blockquote></li><li>Describe z-index and how stacking context is formed.<blockquote><p>描述一下z-index和它是如何与其他的元素堆叠在一起的</p></blockquote></li><li>Describe BFC(Block Formatting Context) and how it works.<blockquote><p> 描述下BFC（块级格式化上下文）以及其工作原理？</p></blockquote></li><li>What are the various clearing techniques and which is appropriate for what context?<blockquote><p> 什么是各种结算技术，都是用于什么背景？</p></blockquote></li><li>Explain CSS sprites, and how you would implement them on a page or site.<blockquote><p> 解释CSS sprites，以及如何在页面或站点上实现它们？</p></blockquote></li><li>What are your favourite image replacement techniques and which do you use when?<blockquote><p> 你最喜欢的图像替换技术是什么？你会什么时候使用？</p></blockquote></li><li>How would you approach fixing browser-specific styling issues?<blockquote><p> 如何解决浏览器特定的样式问题？</p></blockquote></li><li>How do you serve your pages for feature-constrained browsers?<blockquote><p>如何为你的页面提供浏览器受限制的特性</p></blockquote></li></ul><ul><li>What techniques/processes do you use?<blockquote><p> 你使用的是什么技术，以及过程？</p></blockquote></li><li>What are the different ways to visually hide content (and make it available only for screen readers)?<blockquote><p> 有什么不同的方式来直观地隐藏内容（并使其仅适用于屏幕阅读器）？</p></blockquote></li><li>Have you ever used a grid system, and if so, what do you prefer?<blockquote><p> 你有没有用过栅格系统，有过有，你喜欢它什么？</p></blockquote></li><li>Have you used or implemented media queries or mobile specific layouts/CSS?<blockquote><p> 您使用或实现了媒体查询或移动特定布局</p></blockquote></li><li>Are you familiar with styling SVG?<blockquote><p> 你熟悉SVG样式吗？</p></blockquote></li><li>How do you optimize your webpages for print?<blockquote><p> 如何优化网页打印？</p></blockquote></li><li>What are some of the “gotchas” for writing efficient CSS?<blockquote><p> 什么是编写高效CSS的“窍门”？</p></blockquote></li><li>What are the advantages/disadvantages of using CSS preprocessors?<blockquote><p> 使用CSS预处理器的优点和缺点是什么？</p></blockquote></li><li>Describe what you like and dislike about the CSS preprocessors you have used.<blockquote><p> 描述你喜欢和不喜欢你使用的CSS预处理器。</p></blockquote></li><li>How would you implement a web design comp that uses non-standard fonts?<blockquote><p> 如何实现使用非标准字体的Web设计COMP？</p></blockquote></li><li>Explain how a browser determines what elements match a CSS selector.<blockquote><p> 解释浏览器如何确定哪些元素与CSS选择器匹配。</p></blockquote></li><li>Describe pseudo-elements and discuss what they are used for.<blockquote><p> 描述伪元素并讨论它们的用途。</p></blockquote></li><li>Explain your understanding of the box model and how you would tell the browser in CSS to render your layout in different box models.<blockquote><p> 解释您对模型的理解，以及如何告诉CSS中的浏览器在不同的盒模型中呈现布局。</p></blockquote></li><li>What does * { box-sizing: border-box; } do? What are its advantages?<blockquote><p> { box-sizing: border-box; }是做什么的？它的有点是什么</p></blockquote></li><li>List as many values for the display property that you can remember.<blockquote><p> 尽可能的列出你记住的display的属性值</p></blockquote></li><li>What’s the difference between inline and inline-block?</li><li>inline与inline-block之间的不同</li><li>What’s the difference between a relative, fixed, absolute and statically positioned element?</li><li>relative，fixed，absoult，和statically这些定位元素之间的不同</li><li>The ‘C’ in CSS stands for Cascading. How is priority determined in assigning styles (a few examples)? How can you use this system to your advantage?</li><li>CSS中的“C”代表级联。如何在分配样式中确定优先级（几个例子）？你如何利用这个系统来发挥你的优势？</li><li>What existing CSS frameworks have you used locally, or in production? How would you change/improve them?<blockquote><p> 现有的CSS框架在本地或生产中使用过吗？你将如何改变/改进它们？</p></blockquote></li><li>Have you played around with the new CSS Flexbox or Grid specs?<blockquote><p> 你使用过新的Flexbox或Grid specs？</p></blockquote></li><li>How is responsive design different from adaptive design?<blockquote><p> 为什么响应设计和适应设计不同？</p></blockquote></li><li>Have you ever worked with retina graphics? If so, when and what techniques did you use?<blockquote><p> 你曾经使用视网膜图形吗？如果是的话，你使用什么技术？</p></blockquote></li><li>Is there any reason you’d want to use translate() instead of absolute positioning, or vice-versa? And why?<blockquote><p> 在什么情况下你想使用translate()代替定位，反之亦然？为什么？</p></blockquote></li></ul><hr><h3 id="JS-Questions"><a href="#JS-Questions" class="headerlink" title="JS Questions:"></a>JS Questions:</h3><ul><li>Explain event delegation<blockquote><p> 解释事件委托</p></blockquote></li><li>Explain how this works in JavaScript<blockquote><p> 解释如何在JavaScript中工作</p></blockquote></li><li>Explain how prototypal inheritance works<blockquote><p> 解释原型继承是如何工作的</p></blockquote></li><li>What do you think of AMD vs CommonJS?<blockquote><p> 你认为AMD和CommonJS那个更好</p></blockquote></li><li>Explain why the following doesn’t work as an IIFE: function foo(){ }();.<blockquote><p> 解释下面的函数不工作作为一个IIFE：function foo(){}()</p></blockquote></li><li>What needs to be changed to properly make it an IIFE?<blockquote><p> 需要改变什么才能使之成为IFIE？</p></blockquote></li><li>What’s the difference between a variable that is: null, undefined or undeclared?<blockquote><p> 变量是空的、未定义的或未声明的变量之间的区别是什么？</p></blockquote></li><li>How would you go about checking for any of these states?<blockquote><p> 你会怎么去检查这些变量</p></blockquote></li><li>What is a closure, and how/why would you use one?<blockquote><p> 什么是闭包，以及如何/为什么要使用？</p></blockquote></li><li>What’s a typical use case for anonymous functions?<blockquote><p> 匿名函数的典型用例是什么？</p></blockquote></li><li>How do you organize your code? (module pattern, classical inheritance?)<blockquote><p> 如何组织代码？（模块模式，经典继承？）</p></blockquote></li><li>What’s the difference between host objects and native objects?<blockquote><p> 主机对象和本地对象有什么区别？</p></blockquote></li><li>Difference between: function Person(){}, var person = Person(), and var person = new Person()?<blockquote><p> 这三个函数之间的区别</p></blockquote></li><li>What’s the difference between .call and .apply?</li><li>call和apply之间的区别？</li><li>Explain Function.prototype.bind.<blockquote><p> 解释一下 Function.prototype.bind.</p></blockquote></li><li>When would you use document.write()?<blockquote><p> 你什么时候会使用document.write()？</p></blockquote></li><li>What’s the difference between feature detection, feature inference, and using the UA string?<blockquote><p> 特性检查，特性推断和UA字符串之间的不同？</p></blockquote></li><li>Explain AJAX in as much detail as possible.<blockquote><p> 尽可能详细的解释AJAX</p></blockquote></li><li>Explain how JSONP works (and how it’s not really AJAX).<blockquote><p> 解释一下JSONP是如何工作的（和为什么他不是AJAX）</p></blockquote></li><li>Have you ever used JavaScript templating?<blockquote><p> 你曾经使用过JavaScript模板吗？</p></blockquote></li><li>If so, what libraries have you used?<blockquote><p> 如果是这样的话，你有用过什么库吗？</p></blockquote></li><li>Explain “hoisting”.<blockquote><p> 解释一下‘hosting’</p></blockquote></li><li>Describe event bubbling.<blockquote><p> 描述一下冒泡事件？</p></blockquote></li><li>What’s the difference between an “attribute” and a “property”?<blockquote><p> “attribute” 和 “property”?之间的区别？</p></blockquote></li><li>Why is extending built-in JavaScript objects not a good idea?<blockquote><p> 为什么继承在JavaScript对象中使用不适合？</p></blockquote></li><li>Difference between document load event and document ready event?<blockquote><p> 文档加载事件与文档准备事件的区别？</p></blockquote></li><li>What is the difference between == and ===?<blockquote><p> == 和 === 之间的不同？</p></blockquote></li><li>Explain the same-origin policy with regards to JavaScript.<blockquote><p> 解释关于JavaScript的同源策略。</p></blockquote></li><li>Make this work:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duplicate([1,2,3,4,5]); // [1,2,3,4,5,1,2,3,4,5]</span><br></pre></td></tr></table></figure><ul><li>Why is it called a Ternary expression, what does the word “Ternary” indicate?<blockquote><p> 为什么它被称为三元表达式，“三元”这个词表示什么？</p></blockquote></li><li>What is “use strict”;? what are the advantages and disadvantages to using it?<blockquote></blockquote></li><li>Create a for loop that iterates up to 100 while outputting “fizz” at multiples of 3, “buzz” at multiples of 5 and “fizzbuzz” at multiples of 3 and 5</li><li>Why is it, in general, a good idea to leave the global scope of a website as-is and never touch it?</li><li>Why would you use something like the load event? Does this event have disadvantages? Do you know any alternatives, and why would you use those?</li><li>Explain what a single page app is and how to make one SEO-friendly.</li><li>What is the extent of your experience with Promises and/or their polyfills?</li><li>What are the pros and cons of using Promises instead of callbacks?</li><li>What are some of the advantages/disadvantages of writing JavaScript code in a language that compiles to JavaScript?</li></ul><hr><h3 id="Testing-Questions"><a href="#Testing-Questions" class="headerlink" title="Testing Questions:"></a>Testing Questions:</h3><ul><li>What are some advantages/disadvantages to testing your code?<blockquote><p> 测试代码有哪些优点/缺点？</p></blockquote></li><li>What tools would you use to test your code’s functionality?<blockquote><p> 你会用什么工具来测试你的代码的功能？</p></blockquote></li><li>What is the difference between a unit test and a functional/integration test?<blockquote><p> 单元测试一个功能和集成测试之间的区别是什么？</p></blockquote></li><li>What is the purpose of a code style linting tool?<blockquote><p> 规范代码的风格的工具的目的是什么？</p></blockquote></li></ul><hr><h3 id="Performance-Questions"><a href="#Performance-Questions" class="headerlink" title="Performance Questions:"></a>Performance Questions:</h3><ul><li>What tools would you use to find a performance bug in your code?<blockquote><p> 你用什么工具来找到代码中的性能缺陷？</p></blockquote></li><li>What are some ways you may improve your website’s scrolling performance?<blockquote><p> 你有什么方法可以提高你的网站的滚动性能？</p></blockquote></li><li>Explain the difference between layout, painting and compositing.<blockquote><p> 解释一下layout，painting，compositing之间的区别?</p></blockquote></li></ul><hr><h3 id="Network-Questions"><a href="#Network-Questions" class="headerlink" title="Network Questions:"></a>Network Questions:</h3><ul><li>Traditionally, why has it been better to serve site assets from multiple domains?<blockquote><p> 传统上，为什么可以更好地为来自多个域的站点资产提供服务？</p></blockquote></li><li>Do your best to describe the process from the time you type in a website’s URL to it finishing loading on your screen.<blockquote><p> 尽你所能描述从你输入一个网站的URL到它完成你的屏幕上的加载的过程。</p></blockquote></li><li>What are the differences between Long-Polling, Websockets and Server-Sent Events?</li><li><p>Long-Polling，Websockets和Server-Sent Events之间的不同？</p></li><li><p>Explain the following request and response headers:</p></li><li>Diff. between Expires, Date, Age and If-Modified-…</li><li>Do Not Track</li><li>Cache-Control</li><li>Transfer-Encoding</li><li>ETag</li><li>X-Frame-Options</li></ul><blockquote><p>解释以下response和request的头信息</p></blockquote><ul><li>What are HTTP actions? List all HTTP actions that you know, and explain them.<blockquote><p> 什么是http请求？列出你所知道的http请求并解释它们</p></blockquote></li></ul><hr><h3 id="Coding-Questions"><a href="#Coding-Questions" class="headerlink" title="Coding Questions:"></a>Coding Questions:</h3><p>Question: What is the value of foo?</p><ul><li>foo的值为多少<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = 10 + &apos;20&apos;;</span><br></pre></td></tr></table></figure></li></ul><p>Question: How would you make this work?</p><blockquote><p> 你怎么做这个工作？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(2, 5); // 7</span><br><span class="line">add(2)(5); // 7</span><br></pre></td></tr></table></figure><p>Question: What value is returned from the following statement?</p><blockquote><p> 下面的语句返回什么值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;i&apos;m a lasagna hog&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>Question: What is the value of window.foo?</p><ul><li>window.foo的值为什么？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( window.foo || ( window.foo = &quot;bar&quot; ) );</span><br></pre></td></tr></table></figure><p>Question: What is the outcome of the two alerts below?</p><blockquote><p> 下面两个函数分别会弹出什么结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = &quot;Hello&quot;;</span><br><span class="line">(function() &#123;</span><br><span class="line">var bar = &quot; World&quot;;</span><br><span class="line">alert(foo + bar);</span><br><span class="line">&#125;)();</span><br><span class="line">alert(foo + bar);</span><br></pre></td></tr></table></figure><p>Question: What is the value of foo.length?</p><ul><li>foo.length的值是什么</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = [];</span><br><span class="line">foo.push(1);</span><br><span class="line">foo.push(2);</span><br></pre></td></tr></table></figure><p>Question: What is the value of foo.x?</p><ul><li>foo.x的结果是什么</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;n: 1&#125;;</span><br><span class="line">var bar = foo;</span><br><span class="line">foo.x = foo = &#123;n: 2&#125;;</span><br></pre></td></tr></table></figure><h3 id="Fun-Questions"><a href="#Fun-Questions" class="headerlink" title="Fun Questions:"></a>Fun Questions:</h3><ul><li>What’s a cool project that you’ve recently worked on?<br>*你最近有没有做什么很酷的项目</li><li>What are some things you like about the developer tools you use?<blockquote><p> 你喜欢哪些开发工具？</p></blockquote></li><li>Do you have any pet projects? What kind?<blockquote><p> 你有很喜欢的项目吗？什么样的？</p></blockquote></li><li>What’s your favorite feature of Internet Explorer?<blockquote><p> 你最喜欢的Internet Explorer的特性是什么？</p></blockquote></li><li>How do you like your coffee?<blockquote><p> 你喜欢喝什么样的咖啡？</p></blockquote></li></ul></script></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> JS </tag>
            
            <tag> 面试 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
